<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My Neighbor Alice Universe - REAL DATA 3D Visualization</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      background: #0a0a1a;
    }
    #container {
      width: 100vw;
      height: 100vh;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 14px;
      max-width: 340px;
      z-index: 100;
      border: 1px solid rgba(125, 211, 252, 0.3);
      backdrop-filter: blur(10px);
    }
    #info h1 {
      font-size: 18px;
      margin-bottom: 8px;
      color: #7dd3fc;
      text-shadow: 0 0 20px rgba(125, 211, 252, 0.5);
    }
    #info .real-data-badge {
      display: inline-block;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: bold;
      margin-left: 8px;
      text-transform: uppercase;
    }
    #info p {
      margin: 5px 0;
      color: #aaa;
      font-size: 12px;
    }
    #info .highlight {
      color: #fbbf24;
    }
    #stats {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 14px;
      z-index: 100;
      border: 1px solid rgba(251, 191, 36, 0.3);
      backdrop-filter: blur(10px);
      min-width: 200px;
    }
    #stats h3 {
      color: #fbbf24;
      margin-bottom: 10px;
      font-size: 14px;
    }
    #stats .stat {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
      font-size: 13px;
    }
    #stats .stat-value {
      color: #4ade80;
      font-weight: bold;
    }
    #stats .source {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.1);
      font-size: 11px;
      color: #666;
    }
    #stats .source span {
      color: #22c55e;
    }
    /* Draggable + Collapsible Panel System */
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: grab;
      user-select: none;
      margin: -15px -20px 10px -20px;
      padding: 10px 15px;
      border-radius: 12px 12px 0 0;
      background: rgba(255,255,255,0.03);
    }
    .panel-header:active { cursor: grabbing; }
    .panel-header h3 { margin: 0; }
    .panel-collapse-btn {
      width: 22px;
      height: 22px;
      border: none;
      background: rgba(255,255,255,0.08);
      color: #888;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      line-height: 22px;
      text-align: center;
      transition: all 0.15s;
      flex-shrink: 0;
    }
    .panel-collapse-btn:hover { background: rgba(255,255,255,0.15); color: #fff; }
    .panel-body { transition: none; }
    .panel-collapsed .panel-body { display: none !important; }
    .panel-collapsed .panel-header { margin-bottom: -15px; border-radius: 12px; }
    .panel-dragging { opacity: 0.85; z-index: 1000 !important; }

    #back-to-world {
      display: none;
      position: fixed;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 200;
      background: linear-gradient(135deg, #7c3aed, #6d28d9);
      color: #fff;
      border: 1px solid rgba(167, 139, 250, 0.4);
      border-radius: 10px;
      padding: 10px 24px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 20px rgba(124, 58, 237, 0.3);
      transition: all 0.2s;
    }
    #back-to-world:hover {
      background: linear-gradient(135deg, #8b5cf6, #7c3aed);
      box-shadow: 0 4px 28px rgba(124, 58, 237, 0.5);
    }
    #plot-tooltip {
      display: none;
      position: fixed;
      z-index: 200;
      background: rgba(0, 0, 0, 0.85);
      color: #e2e8f0;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      pointer-events: none;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(6px);
      max-width: 260px;
      white-space: nowrap;
    }

    #legend {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 15px 20px;
      border-radius: 12px;
      z-index: 100;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
    }
    #legend h3 {
      font-size: 14px;
      margin-bottom: 10px;
      color: #7dd3fc;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin: 6px 0;
      font-size: 12px;
    }
    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    /* Field Guide */
    #field-guide {
      position: absolute;
      bottom: 170px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 15px 20px;
      border-radius: 12px;
      z-index: 100;
      border: 1px solid rgba(251, 146, 60, 0.3);
      backdrop-filter: blur(10px);
      min-width: 280px;
      max-width: 320px;
      max-height: 55vh;
      overflow-y: auto;
    }
    #field-guide h3 {
      color: #fb923c;
      font-size: 14px;
      margin-bottom: 0;
      cursor: pointer;
      user-select: none;
    }
    #field-guide h3:hover { color: #fdba74; }
    #fg-arrow {
      font-size: 10px;
      margin-left: 6px;
      transition: transform 0.2s;
      display: inline-block;
    }
    #fg-arrow.open { transform: rotate(90deg); }
    #fg-tabs {
      display: flex;
      gap: 4px;
      margin: 10px 0 8px;
    }
    .fg-tab {
      padding: 4px 10px;
      font-size: 11px;
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      cursor: pointer;
      color: #aaa;
      transition: all 0.15s;
    }
    .fg-tab:hover { background: rgba(255,255,255,0.1); color: #fff; }
    .fg-tab.active { background: rgba(251,146,60,0.2); color: #fb923c; }
    .fg-panel { font-size: 12px; }
    .fg-node {
      margin: 8px 0;
      padding: 8px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      border-left: 3px solid rgba(251,146,60,0.4);
    }
    .fg-node-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .fg-node-name {
      font-weight: bold;
      color: #fdba74;
      text-transform: capitalize;
    }
    .fg-tier {
      font-size: 10px;
      padding: 1px 6px;
      border-radius: 4px;
      background: rgba(251,146,60,0.15);
      color: #fb923c;
    }
    .fg-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2px 12px;
      font-size: 11px;
      color: #999;
      margin: 4px 0;
    }
    .fg-stats span { color: #ddd; }
    .fg-drops {
      margin-top: 4px;
      font-size: 11px;
    }
    .fg-drop-item {
      color: #a5f3fc;
      display: inline-block;
      margin-right: 6px;
    }
    .fg-drop-amount { color: #666; font-size: 10px; }
    .fg-tool-req {
      font-size: 11px;
      color: #888;
      margin-top: 3px;
    }
    .fg-tool-req span { color: #c4b5fd; }
    .fg-tool-card {
      margin: 6px 0;
      padding: 6px 8px;
      background: rgba(255,255,255,0.03);
      border-radius: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .fg-tool-name {
      color: #c4b5fd;
      text-transform: capitalize;
      font-size: 12px;
    }
    .fg-tool-tiers {
      display: flex;
      gap: 6px;
      font-size: 11px;
    }
    .fg-tool-tier { color: #999; }
    .fg-tool-tier span { color: #ddd; }
    .fg-seed {
      display: inline-block;
      margin: 3px 4px;
      padding: 3px 8px;
      background: rgba(74, 222, 128, 0.1);
      border-radius: 4px;
      color: #4ade80;
      font-size: 11px;
      text-transform: capitalize;
    }

    #land-info {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      padding: 20px;
      border-radius: 12px;
      font-size: 14px;
      max-width: 320px;
      z-index: 100;
      display: none;
      border: 1px solid rgba(251, 191, 36, 0.5);
      backdrop-filter: blur(10px);
    }
    #land-info h2 {
      font-size: 16px;
      margin-bottom: 8px;
      color: #fbbf24;
    }
    #land-info .plot-id {
      font-size: 11px;
      color: #666;
      margin-bottom: 12px;
    }
    #land-info .detail {
      margin: 8px 0;
      display: flex;
      justify-content: space-between;
      font-size: 13px;
    }
    #land-info .label {
      color: #888;
    }
    #land-info .value {
      color: #fff;
      font-weight: 500;
      text-align: right;
      max-width: 60%;
    }
    #land-info .for-sale {
      margin-top: 15px;
      padding: 12px;
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(34, 197, 94, 0.1));
      border-radius: 8px;
      text-align: center;
      border: 1px solid rgba(34, 197, 94, 0.3);
    }
    #land-info .for-sale .price {
      color: #22c55e;
      font-size: 20px;
      font-weight: bold;
    }
    #land-info .for-sale .seller {
      color: #888;
      font-size: 11px;
      margin-top: 4px;
    }
    #land-info .actions {
      display: flex;
      gap: 8px;
      margin-top: 15px;
    }
    #land-info .action-btn {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.2s;
    }
    #land-info .zoom-btn {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: white;
    }
    #land-info .zoom-btn:hover {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      transform: translateY(-1px);
    }
    #land-info .map-btn {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
      text-decoration: none;
      text-align: center;
    }
    #land-info .map-btn:hover {
      background: linear-gradient(135deg, #d97706, #b45309);
      transform: translateY(-1px);
    }
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      color: #4ade80;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
      border: 1px solid rgba(74, 222, 128, 0.3);
    }
    .toast.show {
      opacity: 1;
    }
    #land-info .soil-water {
      display: flex;
      gap: 10px;
      margin-top: 8px;
      font-size: 11px;
    }
    #land-info .soil-water span {
      padding: 4px 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #7dd3fc;
      font-size: 20px;
      z-index: 200;
      text-align: center;
      text-shadow: 0 0 20px rgba(125, 211, 252, 0.5);
    }
    #loading .sub {
      font-size: 14px;
      color: #888;
      margin-top: 10px;
    }
    .pulse {
      animation: pulse 2s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    #chain-stats {
      position: absolute;
      top: 160px;
      right: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 14px;
      z-index: 100;
      border: 1px solid rgba(124, 58, 237, 0.3);
      backdrop-filter: blur(10px);
      min-width: 200px;
    }
    #chain-stats h3 {
      color: #a78bfa;
      margin-bottom: 10px;
      font-size: 14px;
    }
    #chain-stats .stat {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
      font-size: 13px;
    }
    #chain-stats .stat-value {
      color: #c4b5fd;
      font-weight: bold;
    }
    #chain-stats .source {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.1);
      font-size: 11px;
      color: #666;
    }
    #chain-stats .source span {
      color: #7c3aed;
    }
    #chain-stats .section-label {
      color: #8b5cf6;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-top: 10px;
      margin-bottom: 4px;
      padding-top: 8px;
      border-top: 1px solid rgba(124, 58, 237, 0.15);
    }
    #chain-stats .growth {
      color: #4ade80;
      font-size: 11px;
    }
    #chain-stats .growth.negative {
      color: #f87171;
    }
    #leaderboard {
      position: absolute;
      top: 250px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 14px;
      z-index: 100;
      border: 1px solid rgba(251, 146, 60, 0.3);
      backdrop-filter: blur(10px);
      min-width: 220px;
    }
    #leaderboard h3 {
      color: #fb923c;
      margin-bottom: 10px;
      font-size: 14px;
    }
    #leaderboard .player {
      display: flex;
      justify-content: space-between;
      margin: 4px 0;
      font-size: 12px;
    }
    #leaderboard .player .rank {
      color: #666;
      width: 18px;
    }
    #leaderboard .player .name {
      flex: 1;
      color: #ddd;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 110px;
    }
    #leaderboard .player .xp {
      color: #fb923c;
      font-weight: bold;
      font-size: 11px;
    }
    #leaderboard .whale-section {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }
    #leaderboard .whale {
      display: flex;
      justify-content: space-between;
      margin: 3px 0;
      font-size: 11px;
    }
    #leaderboard .whale .label {
      color: #888;
    }
    #leaderboard .whale .value {
      color: #fbbf24;
      font-weight: bold;
    }
    #leaderboard .source {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.1);
      font-size: 11px;
      color: #666;
    }
    #leaderboard .source span {
      color: #fb923c;
    }
    #updating {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #7dd3fc;
      font-size: 14px;
      z-index: 150;
      text-align: center;
      opacity: 0.7;
      pointer-events: none;
      display: none;
    }

    /* Player Search */
    #player-search {
      position: absolute;
      top: 155px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 12px 15px;
      border-radius: 12px;
      font-size: 14px;
      z-index: 100;
      border: 1px solid rgba(6, 182, 212, 0.3);
      backdrop-filter: blur(10px);
      min-width: 220px;
    }
    #player-search h3 {
      color: #06b6d4;
      margin-bottom: 8px;
      font-size: 14px;
    }
    #search-input {
      width: 100%;
      padding: 6px 10px;
      border: 1px solid rgba(6, 182, 212, 0.3);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.08);
      color: #fff;
      font-size: 13px;
      outline: none;
      transition: border-color 0.2s;
    }
    #search-input:focus {
      border-color: #06b6d4;
    }
    #search-input::placeholder {
      color: #666;
    }
    #search-result {
      margin-top: 10px;
      font-size: 12px;
    }
    #search-result .sr-detail {
      display: flex;
      justify-content: space-between;
      margin: 4px 0;
    }
    #search-result .sr-label {
      color: #888;
    }
    #search-result .sr-value {
      color: #06b6d4;
      font-weight: bold;
    }
    #search-result .sr-plots {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }
    #search-result .sr-plots .sr-plot-btn {
      display: inline-block;
      background: rgba(6, 182, 212, 0.15);
      border: 1px solid rgba(6, 182, 212, 0.3);
      color: #06b6d4;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      margin: 2px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #search-result .sr-plots .sr-plot-btn:hover {
      background: rgba(6, 182, 212, 0.3);
    }
    #search-error {
      color: #f87171;
      font-size: 12px;
      margin-top: 6px;
    }

    /* Storefront */
    #storefront {
      position: absolute;
      right: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 14px;
      z-index: 100;
      border: 1px solid rgba(34, 197, 94, 0.3);
      backdrop-filter: blur(10px);
      min-width: 200px;
      max-height: 300px;
      overflow-y: auto;
    }
    #storefront h3 {
      color: #22c55e;
      margin-bottom: 10px;
      font-size: 14px;
    }
    #storefront-list .sf-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 4px 0;
      font-size: 12px;
      padding: 3px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    #storefront-list .sf-name {
      color: #ddd;
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 100px;
    }
    #storefront-list .sf-price {
      color: #22c55e;
      font-weight: bold;
      font-size: 11px;
      margin-left: 8px;
    }
    #storefront-list .sf-count {
      color: #666;
      font-size: 10px;
      margin-left: 6px;
      min-width: 30px;
      text-align: right;
    }
    #storefront .source {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.1);
      font-size: 11px;
      color: #666;
    }
    #storefront .source span {
      color: #22c55e;
    }

    /* Plot Deep Dive */
    #plot-deep-dive .section-divider {
      border-top: 1px solid rgba(139, 92, 246, 0.3);
      margin: 12px 0;
    }
    .deep-dive-section {
      margin: 8px 0;
    }
    .deep-dive-section .section-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #8b5cf6;
      margin-bottom: 4px;
    }
    .deep-dive-section .dd-content {
      font-size: 12px;
      color: #ccc;
      line-height: 1.5;
    }
    #plot-terrain-canvas {
      border: 1px solid rgba(139,92,246,0.3);
      border-radius: 4px;
      display: block;
      margin-top: 4px;
    }
    #land-info {
      max-height: 70vh;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <div id="info">
    <h1>My Neighbor Alice<span class="real-data-badge">REAL DATA</span></h1>
    <p>Pan: Right-click + drag | Zoom: Scroll | Rotate: Left-click + drag</p>
    <p class="highlight">Click on a land to see details</p>
    <p class="highlight pulse">Golden glowing lands are FOR SALE!</p>
  </div>

  <div id="stats" class="draggable-panel">
    <div class="panel-header"><h3>World Statistics</h3><button class="panel-collapse-btn" title="Minimize">‚àí</button></div>
    <div class="panel-body">
    <div class="stat">
      <span>Total Lands:</span>
      <span class="stat-value" id="total-lands">0</span>
    </div>
    <div class="stat">
      <span>For Sale:</span>
      <span class="stat-value" id="for-sale-count">0</span>
    </div>
    <div class="stat">
      <span>Price Range:</span>
      <span class="stat-value" id="price-range">-</span>
    </div>
    <div class="stat">
      <span>Islands:</span>
      <span class="stat-value" id="island-count">0</span>
    </div>
    <div class="source">
      Data: <span id="data-source">loading...</span>
    </div>
    </div>
  </div>


  <div id="chain-stats" class="draggable-panel">
    <div class="panel-header"><h3>Chromia Blockchain</h3><button class="panel-collapse-btn" title="Minimize">‚àí</button></div>
    <div class="panel-body">
    <div class="stat">
      <span>Total Players:</span>
      <span class="stat-value" id="chain-players">--</span>
    </div>
    <div id="chain-growth" class="growth" style="display:none; text-align:right;"></div>
    <div class="stat">
      <span>On-Chain Assets:</span>
      <span class="stat-value" id="chain-assets">--</span>
    </div>
    <div class="stat">
      <span>Game Version:</span>
      <span class="stat-value" id="chain-version">--</span>
    </div>
    <div class="section-label">Game Economy</div>
    <div class="stat">
      <span>Crops / Seeds:</span>
      <span class="stat-value" id="econ-farming">--</span>
    </div>
    <div class="stat">
      <span>Fish Species:</span>
      <span class="stat-value" id="econ-fishing">--</span>
    </div>
    <div class="stat">
      <span>Recipes:</span>
      <span class="stat-value" id="econ-recipes">--</span>
    </div>
    <div class="stat">
      <span>Quests:</span>
      <span class="stat-value" id="econ-quests">--</span>
    </div>
    <div class="stat">
      <span>Shop Items:</span>
      <span class="stat-value" id="econ-shop">--</span>
    </div>
    <div class="stat">
      <span>NPCs / Tools:</span>
      <span class="stat-value" id="econ-misc">--</span>
    </div>
    <div class="source">
      Source: <span id="chain-source">loading...</span>
    </div>
    </div>
  </div>

  <div id="player-search" class="draggable-panel">
    <div class="panel-header"><h3>Player Lookup</h3><button class="panel-collapse-btn" title="Minimize">‚àí</button></div>
    <div class="panel-body">
    <input type="text" id="search-input" placeholder="Search player..." />
    <div id="search-result" style="display:none;"></div>
    <div id="search-error" style="display:none;"></div>
    </div>
  </div>

  <div id="storefront" class="draggable-panel">
    <div class="panel-header"><h3>P2P Marketplace</h3><button class="panel-collapse-btn" title="Minimize">‚àí</button></div>
    <div class="panel-body">
    <div id="storefront-list">Loading...</div>
    <div class="source">Source: <span id="sf-source">loading...</span></div>
    </div>
  </div>

  <div id="leaderboard" class="draggable-panel">
    <div class="panel-header"><h3>Top Players (XP)</h3><button class="panel-collapse-btn" title="Minimize">‚àí</button></div>
    <div class="panel-body">
    <div id="leaderboard-list"></div>
    <div class="whale-section">
      <div id="whale-list"></div>
    </div>
    <div class="source">
      Source: <span id="lb-source">loading...</span>
    </div>
    </div>
  </div>

  <div id="legend" class="draggable-panel">
    <div class="panel-header"><h3>Regions / Biomes</h3><button class="panel-collapse-btn" title="Minimize">‚àí</button></div>
    <div class="panel-body">
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(135deg, #4ade80, #22c55e);"></div>
      <span>Plains / Wolds</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(135deg, #166534, #14532d);"></div>
      <span>Forest / Gulch</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(135deg, #fbbf24, #d4a574);"></div>
      <span>Desert / Sandy</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(135deg, #38bdf8, #0ea5e9);"></div>
      <span>Water / Falls</span>
    </div>
    </div>
  </div>

  <div id="field-guide" class="draggable-panel">
    <div class="panel-header"><h3 id="field-guide-toggle" style="cursor:pointer;">Field Guide <span id="fg-arrow">&#9654;</span></h3><button class="panel-collapse-btn" title="Minimize">‚àí</button></div>
    <div class="panel-body">
    <div id="fg-content" style="display:none;">
      <div id="fg-tabs">
        <span class="fg-tab active" data-tab="nodes">Resources</span>
        <span class="fg-tab" data-tab="tools">Tools</span>
        <span class="fg-tab" data-tab="mystery">Seeds</span>
      </div>
      <div id="fg-panel-nodes" class="fg-panel"></div>
      <div id="fg-panel-tools" class="fg-panel" style="display:none;"></div>
      <div id="fg-panel-mystery" class="fg-panel" style="display:none;"></div>
      <div class="source">Source: <span id="fg-source">loading...</span></div>
    </div>
    </div>
  </div>

  <div id="land-info" class="draggable-panel">
    <div class="panel-header"><h3 style="font-size:16px;">Land Details</h3><button class="panel-collapse-btn" title="Minimize">‚àí</button></div>
    <div class="panel-body">
    <h2 id="land-name">Land Name</h2>
    <div class="plot-id" id="plot-id">Plot #0000000</div>
    <div class="detail">
      <span class="label">Island</span>
      <span class="value" id="land-island">Unknown</span>
    </div>
    <div class="detail">
      <span class="label">Region</span>
      <span class="value" id="land-region">Unknown</span>
    </div>
    <div class="detail">
      <span class="label">Coordinates</span>
      <span class="value" id="land-coords">(0, 0)</span>
    </div>
    <div class="detail">
      <span class="label">Biome</span>
      <span class="value" id="land-biome">Plains</span>
    </div>
    <div class="soil-water">
      <span id="land-soil">Soil: unknown</span>
      <span id="land-water">Water: unknown</span>
    </div>
    <div id="land-sale" class="for-sale" style="display: none;">
      <div class="price"><span id="land-price">0</span> ALICE</div>
      <div class="seller">Seller: <span id="land-seller">Unknown</span></div>
    </div>
    <div class="actions">
      <button class="action-btn zoom-btn" id="zoom-btn">üîç Zoom</button>
      <a class="action-btn map-btn" id="map-btn" href="#" target="_blank">üó∫Ô∏è MNA Map</a>
    </div>
    <div id="dblclick-hint" style="text-align:center; color:#666; font-size:11px; margin-top:8px; font-style:italic;">Double-click tile for deep dive</div>
    <div id="plot-deep-dive" style="display:none;">
      <div class="section-divider"></div>
      <div class="deep-dive-section">
        <div class="section-title">üìã Plot Info</div>
        <div class="dd-content" id="plot-meta">Loading...</div>
      </div>
      <div class="deep-dive-section">
        <div class="section-title">üåæ Farming</div>
        <div class="dd-content" id="plot-farming">Loading...</div>
      </div>
      <div class="deep-dive-section">
        <div class="section-title">üêü Fishing</div>
        <div class="dd-content" id="plot-fishing">Loading...</div>
      </div>
      <div class="deep-dive-section">
        <div class="section-title">‚õèÔ∏è Resources</div>
        <div class="dd-content" id="plot-nodes">Loading...</div>
      </div>
      <div class="deep-dive-section">
        <div class="section-title">üè† Placeables</div>
        <div class="dd-content" id="plot-placeables">Loading...</div>
      </div>
      <div class="deep-dive-section">
        <div class="section-title">üë§ Avatar</div>
        <div class="dd-content" id="plot-avatar">Loading...</div>
      </div>
      <div class="deep-dive-section">
        <div class="section-title">üó∫Ô∏è Terrain</div>
        <div class="dd-content" id="plot-map">Loading...</div>
      </div>
    </div>
    </div>
  </div>

  <button id="back-to-world">&#8592; Back to World</button>
  <div id="plot-tooltip"></div>

  <div id="loading">
    Loading Real MNA Universe...
    <div class="sub">Fetching from mkpl-api.prod.myneighboralice.com</div>
  </div>

  <div id="updating">Updating land data...</div>

  <div id="toast" class="toast">Plot ID copied!</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Biome colors
    const BIOME_COLORS = {
      plains: 0x4ade80,
      forest: 0x166534,
      desert: 0xd4a574,
      water: 0x38bdf8,
    };

    // Biome heights
    const BIOME_HEIGHTS = {
      plains: 0.3,
      forest: 0.5,
      desert: 0.2,
      water: -0.1,
    };

    // Scene setup
    const container = document.getElementById('container');
    const scene = new THREE.Scene();

    // Create gradient sky
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.ShaderMaterial({
      uniforms: {
        topColor: { value: new THREE.Color(0x0a0a2e) },
        bottomColor: { value: new THREE.Color(0x1a1a4e) },
        offset: { value: 33 },
        exponent: { value: 0.6 }
      },
      vertexShader: `
        varying vec3 vWorldPosition;
        void main() {
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 topColor;
        uniform vec3 bottomColor;
        uniform float offset;
        uniform float exponent;
        varying vec3 vWorldPosition;
        void main() {
          float h = normalize(vWorldPosition + offset).y;
          gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
        }
      `,
      side: THREE.BackSide
    });
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    // Add stars
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 2000;
    const starPositions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount * 3; i += 3) {
      const radius = 400 + Math.random() * 50;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      starPositions[i] = radius * Math.sin(phi) * Math.cos(theta);
      starPositions[i + 1] = radius * Math.cos(phi);
      starPositions[i + 2] = radius * Math.sin(phi) * Math.sin(theta);
    }
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8 });
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    // Camera - far clipping plane extended for large world
    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      2000
    );
    camera.position.set(80, 60, 80);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // Controls - extended for large world
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 500;
    controls.maxPolarAngle = Math.PI / 2.1;

    // Lights
    const ambientLight = new THREE.AmbientLight(0x404080, 0.5);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfff5e0, 1.2);
    sunLight.position.set(100, 80, 60);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 4096;
    sunLight.shadow.mapSize.height = 4096;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 400;
    sunLight.shadow.camera.left = -150;
    sunLight.shadow.camera.right = 150;
    sunLight.shadow.camera.top = 150;
    sunLight.shadow.camera.bottom = -150;
    scene.add(sunLight);

    const rimLight = new THREE.DirectionalLight(0x8080ff, 0.3);
    rimLight.position.set(-20, 10, -20);
    scene.add(rimLight);

    // Ocean plane - large enough for full coordinate range
    const oceanGeometry = new THREE.PlaneGeometry(500, 500);
    const oceanMaterial = new THREE.MeshPhongMaterial({
      color: 0x0066aa,
      transparent: true,
      opacity: 0.7,
      shininess: 100,
    });
    const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
    ocean.rotation.x = -Math.PI / 2;
    ocean.position.set(80, -0.5, 45); // Center on the coordinate range
    scene.add(ocean);

    // Store land meshes for raycasting
    const landMeshes = [];
    const landDataMap = new Map();
    const forSaleMeshes = [];

    // Create a tree
    function createTree(x, z, scale = 1) {
      const group = new THREE.Group();

      const trunkGeometry = new THREE.CylinderGeometry(0.05 * scale, 0.08 * scale, 0.4 * scale, 8);
      const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = 0.2 * scale;
      trunk.castShadow = true;
      group.add(trunk);

      const foliageGeometry = new THREE.ConeGeometry(0.2 * scale, 0.5 * scale, 8);
      const foliageMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
      const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
      foliage.position.y = 0.55 * scale;
      foliage.castShadow = true;
      group.add(foliage);

      group.position.set(x, 0, z);
      return group;
    }

    // Create a building
    function createBuilding(type, scale = 1) {
      const group = new THREE.Group();

      if (type === 'house') {
        const baseGeometry = new THREE.BoxGeometry(0.5 * scale, 0.4 * scale, 0.5 * scale);
        const baseMaterial = new THREE.MeshPhongMaterial({ color: 0xf5deb3 });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = 0.2 * scale;
        base.castShadow = true;
        group.add(base);

        const roofGeometry = new THREE.ConeGeometry(0.45 * scale, 0.3 * scale, 4);
        const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x8B0000 });
        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
        roof.position.y = 0.55 * scale;
        roof.rotation.y = Math.PI / 4;
        roof.castShadow = true;
        group.add(roof);
      } else if (type === 'tower') {
        const towerGeometry = new THREE.CylinderGeometry(0.15 * scale, 0.2 * scale, 0.8 * scale, 8);
        const towerMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
        const tower = new THREE.Mesh(towerGeometry, towerMaterial);
        tower.position.y = 0.4 * scale;
        tower.castShadow = true;
        group.add(tower);

        const topGeometry = new THREE.ConeGeometry(0.2 * scale, 0.25 * scale, 8);
        const topMaterial = new THREE.MeshPhongMaterial({ color: 0x4169E1 });
        const top = new THREE.Mesh(topGeometry, topMaterial);
        top.position.y = 0.9 * scale;
        top.castShadow = true;
        group.add(top);
      }

      return group;
    }

    // Create land mesh with terrain
    function createLandMesh(land) {
      const group = new THREE.Group();
      const baseHeight = BIOME_HEIGHTS[land.biome] || 0.3;
      const color = BIOME_COLORS[land.biome] || 0x888888;

      // Use actual land dimensions, with a minimum size for visibility
      const landWidth = Math.max(land.width || 0.8, 0.5);
      const landDepth = Math.max(land.height || 0.8, 0.5);
      const landSize = Math.max(landWidth, landDepth);

      // Main terrain block
      const geometry = new THREE.BoxGeometry(landWidth * 0.95, baseHeight + 0.1, landDepth * 0.95);
      const material = new THREE.MeshPhongMaterial({
        color: color,
        shininess: land.biome === 'water' ? 80 : 20,
        transparent: land.biome === 'water',
        opacity: land.biome === 'water' ? 0.85 : 1,
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.y = (baseHeight + 0.1) / 2;
      mesh.castShadow = true;
      mesh.receiveShadow = true;

      mesh.userData = { landId: land.id };
      landDataMap.set(land.id, land);
      landMeshes.push(mesh);

      group.add(mesh);

      // Add decorations based on biome (scaled to land size)
      if (land.biome === 'forest' && landSize > 0.3) {
        const treeCount = Math.floor(1 + Math.random() * 2);
        for (let i = 0; i < treeCount; i++) {
          const tx = (Math.random() - 0.5) * landWidth * 0.6;
          const tz = (Math.random() - 0.5) * landDepth * 0.6;
          const scale = 0.3 + Math.random() * 0.3;
          const tree = createTree(tx, tz, scale);
          tree.position.y = baseHeight + 0.1;
          group.add(tree);
        }
      }

      // Add buildings to some plains
      if (land.biome === 'plains' && Math.random() > 0.85 && landSize > 0.5) {
        const buildingType = Math.random() > 0.5 ? 'house' : 'tower';
        const building = createBuilding(buildingType, 0.5);
        building.position.y = baseHeight + 0.1;
        group.add(building);
      }

      // For sale glow effect
      if (land.forSale) {
        const glowGeometry = new THREE.BoxGeometry(landWidth, 0.02, landDepth);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0xfbbf24,
          transparent: true,
          opacity: 0.6,
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.position.y = baseHeight + 0.12;
        group.add(glow);

        // Vertical beam
        const beamGeometry = new THREE.CylinderGeometry(0.03, 0.03, 3, 8);
        const beamMaterial = new THREE.MeshBasicMaterial({
          color: 0xfbbf24,
          transparent: true,
          opacity: 0.4,
        });
        const beam = new THREE.Mesh(beamGeometry, beamMaterial);
        beam.position.y = baseHeight + 1.6;
        group.add(beam);

        forSaleMeshes.push({ glow, beam, baseOpacity: 0.6 });
      }

      // Position the group using scaled coordinates
      group.position.set(land.x, 0, land.y);

      return group;
    }

    // Fetch and render lands
    let landsRendered = false;

    function renderLands(lands, stats, source) {
      // Clear previous land meshes
      if (landsRendered) {
        landMeshes.forEach(mesh => {
          // mesh is inside a Group; remove the Group from the scene
          const group = mesh.parent;
          if (group) scene.remove(group);
        });
        landMeshes.length = 0;
        landDataMap.clear();
        forSaleMeshes.length = 0;
      }

      // Update stats
      document.getElementById('total-lands').textContent = lands.length;
      const forSaleLands = lands.filter(l => l.forSale);
      document.getElementById('for-sale-count').textContent = forSaleLands.length;

      if (forSaleLands.length > 0) {
        const prices = forSaleLands.map(l => l.price || 0).filter(p => p > 0);
        if (prices.length > 0) {
          const minPrice = Math.min(...prices);
          const maxPrice = Math.max(...prices);
          document.getElementById('price-range').textContent = `${minPrice}-${maxPrice} ALICE`;
        }
      }

      if (stats) {
        document.getElementById('island-count').textContent = stats.islands?.length || 1;

      }

      document.getElementById('data-source').textContent = source || 'mna-marketplace-api';

      // Render land meshes
      lands.forEach(land => {
        const mesh = createLandMesh(land);
        scene.add(mesh);
      });

      // Center camera on first render
      if (!landsRendered && lands.length > 0) {
        const xs = lands.map(l => l.x);
        const ys = lands.map(l => l.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const worldWidth = maxX - minX;
        const worldDepth = maxY - minY;
        const worldSize = Math.max(worldWidth, worldDepth);

        controls.target.set(centerX, 0, centerY);
        const cameraDistance = worldSize * 0.6;
        camera.position.set(centerX + cameraDistance * 0.5, cameraDistance * 0.4, centerY + cameraDistance * 0.5);

        console.log(`World bounds: X(${minX.toFixed(1)}-${maxX.toFixed(1)}), Y(${minY.toFixed(1)}-${maxY.toFixed(1)})`);
        console.log(`World center: (${centerX.toFixed(1)}, ${centerY.toFixed(1)}), size: ${worldSize.toFixed(1)}`);
      }

      landsRendered = true;
      document.getElementById('loading').style.display = 'none';
    }

    async function loadLands() {
      const CACHE_KEY = 'mna_lands_cache';
      const CACHE_MAX_AGE = 10 * 60 * 1000; // 10 minutes

      // Check localStorage for cached data
      let cachedResult = null;
      try {
        const raw = localStorage.getItem(CACHE_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          if (parsed.timestamp && (Date.now() - parsed.timestamp) < CACHE_MAX_AGE) {
            cachedResult = parsed;
          }
        }
      } catch (e) {
        console.warn('Failed to read cache:', e);
      }

      // If we have valid cached data, render immediately
      if (cachedResult) {
        console.log(`Rendering ${cachedResult.data.length} lands from localStorage cache`);
        renderLands(cachedResult.data, cachedResult.stats, cachedResult.source + ' (cached)');

        // Background refresh
        document.getElementById('updating').style.display = 'block';
        try {
          const response = await fetch('/api/v1/lands');
          const result = await response.json();
          if (result.success && result.data) {
            // Save to localStorage
            try {
              localStorage.setItem(CACHE_KEY, JSON.stringify({
                data: result.data,
                stats: result.stats,
                source: result.source,
                timestamp: Date.now(),
              }));
            } catch (e) {
              console.warn('Failed to write cache:', e);
            }

            // Re-render if data changed
            if (result.data.length !== cachedResult.data.length) {
              console.log(`Data changed (${cachedResult.data.length} -> ${result.data.length}), re-rendering`);
              renderLands(result.data, result.stats, result.source);
            }
          }
        } catch (error) {
          console.warn('Background refresh failed:', error);
        } finally {
          document.getElementById('updating').style.display = 'none';
        }
        return;
      }

      // No cache ‚Äî full loading screen fetch
      try {
        const response = await fetch('/api/v1/lands');
        const result = await response.json();

        if (result.success && result.data) {
          console.log(`Loaded ${result.data.length} REAL lands from ${result.source}`);

          // Save to localStorage
          try {
            localStorage.setItem(CACHE_KEY, JSON.stringify({
              data: result.data,
              stats: result.stats,
              source: result.source,
              timestamp: Date.now(),
            }));
          } catch (e) {
            console.warn('Failed to write cache:', e);
          }

          renderLands(result.data, result.stats, result.source);
        }
      } catch (error) {
        console.error('Failed to load lands:', error);
        document.getElementById('loading').innerHTML =
          'Failed to load lands.<br><span class="sub">Is the server running?</span>';
      }
    }

    // Raycaster for click detection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedMesh = null;
    let selectedLand = null;

    // === 3D Plot View State ===
    let viewMode = 'world'; // 'world' | 'plot'
    let plotViewGroup = null;
    let savedCameraState = null;
    let hiddenWorldObjects = [];
    let currentPlotData = null;

    // Rotation map for placeables and nodes
    const ROTATION_MAP = { north: 0, east: -Math.PI / 2, south: Math.PI, west: Math.PI / 2 };

    // Clean name helper
    function cleanPlaceableName(name) {
      return name
        .replace(/^(placeable_|equippable_|seed_|fish_|resourcenode_|craftingstation_)/, '')
        .replace(/_/g, ' ')
        .replace(/\b\w/g, c => c.toUpperCase());
    }

    // === TERRAIN BUILDER ===
    function buildTerrain(mapData) {
      const group = new THREE.Group();
      group.name = 'terrain';
      if (!mapData || !mapData.cells) return group;

      const rawCells = mapData.cells;
      const textureArr = mapData.texture || [];
      const area = mapData.area || {};
      const gridW = area.size?.width || 100;
      const rawRows = Math.floor(rawCells.length / gridW);

      // The cells array is interleaved: even rows = terrain type, odd rows = elevation
      // 20,000 entries = 200 rows of 100 = 100x100 grid with 2 layers
      const isInterleaved = rawRows === gridW * 2;
      const gridH = isInterleaved ? rawRows / 2 : rawRows;

      // Decode the two layers
      const terrainType = new Array(gridW * gridH);
      const elevation = new Array(gridW * gridH);

      if (isInterleaved) {
        for (let row = 0; row < gridH; row++) {
          for (let x = 0; x < gridW; x++) {
            terrainType[row * gridW + x] = rawCells[(row * 2) * gridW + x] ?? 0;
            elevation[row * gridW + x] = rawCells[(row * 2 + 1) * gridW + x] ?? 0;
          }
        }
      } else {
        // Fallback: treat as flat type-only grid
        for (let i = 0; i < rawCells.length; i++) {
          terrainType[i] = rawCells[i] ?? 0;
          elevation[i] = 0;
        }
      }

      // Terrain type colors (from 20-plot survey of 400k cells)
      const typeColors = {
        0:  0x2563eb,  // deep water
        1:  0x16a34a,  // grass
        2:  0x92400e,  // dirt/earth
        3:  0xeab308,  // sand
        4:  0x4ade80,  // light grass / meadow
        5:  0x713f12,  // dark soil / fertile
        6:  0x78716c,  // rocky ground
        7:  0x6b5c3e,  // mud / wetland
        8:  0x60a5fa,  // shallow water / marsh
        9:  0xa8a29e,  // gravel / pebbles
        10: 0x57534e,  // cliff / stone
        11: 0x15803d,  // dense vegetation
        12: 0xd6b88a,  // path / road
        13: 0x166534,  // forest floor
        14: 0x1e3a5f,  // deep river
        15: 0xc2b280,  // dry sand
        16: 0x4a5568,  // dark stone
        17: 0x8b5e3c,  // clay
        18: 0x2d6a4f,  // moss
        19: 0x9f7e55,  // dried earth
        20: 0xb8c4a8,  // pale grass
        21: 0x5c4033,  // dark rock
        22: 0x7c9a3e,  // scrubland
        23: 0x3a7ca5,  // pond
        24: 0x6d6027,  // loam
        25: 0xbfa76a,  // sandstone
        26: 0x4a7c59,  // fern ground
        27: 0xc9b89e,  // chalk
        28: 0x8e735b,  // packed earth
        29: 0x2e4057,  // slate
        30: 0x536b4e,  // forest moss
        31: 0xd4a76a,  // dune
        32: 0x8b7355,  // silt
        33: 0x5e7346,  // undergrowth
        34: 0x3d5a80,  // tidal pool
        35: 0xa0522d,  // red earth
        36: 0x6b8e6b,  // meadow clover
        37: 0x9e9e78,  // dry grass
        38: 0x708090,  // flagstone
        39: 0x556b2f,  // ivy ground
        41: 0x8fbc8f,  // sage grass
        43: 0xbc8f8f,  // rose earth
        44: 0x696969,  // boulder
        45: 0x4682b4,  // stream
        46: 0x2f4f4f,  // dark cliff
        47: 0xdaa520,  // golden sand
        48: 0x5f9ea0,  // lagoon
        49: 0x7b6b4a,  // peat
        50: 0x9acd32,  // fresh sprout
      };
      const defaultColor = 0x888888;

      // Texture overlay colors: player-placed ground decorations (paths, courtyards, zones)
      const texOverlayColors = {
        1: new THREE.Color(0xc9b89e),  // warm stone paving
        2: new THREE.Color(0xd4a574),  // sandy path / border
        3: new THREE.Color(0xa8c090),  // garden / decorative green
      };
      const texBlendStrength = 0.55;

      // Elevation scaling: gentle terrain (raw 0-25 ‚Üí 0-2.0 world units over a 100-unit grid)
      const elevScale = 0.08;

      // Build a smooth heightmap plane instead of individual boxes
      // This gives continuous terrain with vertex coloring ‚Äî 1 draw call, no gaps
      const planeGeo = new THREE.PlaneGeometry(gridW, gridH, gridW - 1, gridH - 1);
      planeGeo.rotateX(-Math.PI / 2); // lay flat (XZ plane)

      const positions = planeGeo.attributes.position;
      const colors = new Float32Array(positions.count * 3);

      for (let i = 0; i < positions.count; i++) {
        // PlaneGeometry vertices go left‚Üíright, top‚Üíbottom after rotation
        // Map vertex index to grid cell
        const gx = i % gridW;
        const gz = Math.floor(i / gridW);
        const cellIdx = gz * gridW + gx;

        // Displace Y by elevation
        const elev = (cellIdx < elevation.length ? elevation[cellIdx] : 0) * elevScale;
        positions.setY(i, elev);

        // Shift so grid goes from 0..gridW-1 (centered at gridW/2)
        positions.setX(i, gx);
        positions.setZ(i, gz);

        // Vertex color: terrain type + texture blend
        const t = cellIdx < terrainType.length ? terrainType[cellIdx] : 0;
        const tex = (textureArr.length > 0 && cellIdx < textureArr.length) ? textureArr[cellIdx] : 0;
        const c = new THREE.Color(typeColors[t] ?? defaultColor);
        if (tex > 0 && texOverlayColors[tex]) {
          c.lerp(texOverlayColors[tex], texBlendStrength);
        }
        colors[i * 3] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
      }

      // Smooth vertex colors: multiple passes of box blur to soften harsh terrain banding
      // Each pass averages with 8 neighbors (cardinal + diagonal)
      let src = colors;
      const SMOOTH_PASSES = 3;
      for (let pass = 0; pass < SMOOTH_PASSES; pass++) {
        const dst = new Float32Array(src.length);
        for (let i = 0; i < positions.count; i++) {
          const gx = i % gridW;
          const gz = Math.floor(i / gridW);
          let r = src[i*3] * 2, g = src[i*3+1] * 2, b = src[i*3+2] * 2; // center weighted 2x
          let weight = 2;
          for (let dz = -1; dz <= 1; dz++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dz === 0) continue;
              const nx = gx + dx, nz = gz + dz;
              if (nx >= 0 && nx < gridW && nz >= 0 && nz < gridH) {
                const ni = nz * gridW + nx;
                const w = (dx === 0 || dz === 0) ? 1.0 : 0.7; // diagonals weighted less
                r += src[ni*3] * w; g += src[ni*3+1] * w; b += src[ni*3+2] * w;
                weight += w;
              }
            }
          }
          dst[i*3] = r / weight;
          dst[i*3+1] = g / weight;
          dst[i*3+2] = b / weight;
        }
        src = dst;
      }

      planeGeo.setAttribute('color', new THREE.BufferAttribute(src, 3));
      planeGeo.computeVertexNormals();
      positions.needsUpdate = true;

      const planeMat = new THREE.MeshPhongMaterial({
        vertexColors: true,
        flatShading: false,
        shininess: 10,
      });
      const planeMesh = new THREE.Mesh(planeGeo, planeMat);
      planeMesh.name = 'terrain_plane';
      planeMesh.receiveShadow = true;
      group.add(planeMesh);

      // Add terrain skirt: walls around the edges so the thin plane isn't visible from the side
      const skirtDepth = 3;
      const skirtMat = new THREE.MeshPhongMaterial({ color: 0x3d3530 });
      // 4 sides: front (z=0), back (z=gridH-1), left (x=0), right (x=gridW-1)
      const sides = [
        { axis: 'z', val: 0, len: gridW, getElev: (i) => elevation[i] },                           // front
        { axis: 'z', val: gridH - 1, len: gridW, getElev: (i) => elevation[(gridH-1)*gridW + i] }, // back
        { axis: 'x', val: 0, len: gridH, getElev: (i) => elevation[i * gridW] },                   // left
        { axis: 'x', val: gridW - 1, len: gridH, getElev: (i) => elevation[i * gridW + gridW - 1] }, // right
      ];
      for (const side of sides) {
        const geo = new THREE.BufferGeometry();
        const verts = [];
        for (let i = 0; i < side.len; i++) {
          const elev = (side.getElev(i) || 0) * elevScale;
          const bottom = elev - skirtDepth;
          if (side.axis === 'z') {
            verts.push(i, elev, side.val,   i, bottom, side.val,   i+1, elev, side.val);
            verts.push(i+1, elev, side.val,  i, bottom, side.val,   i+1, bottom, side.val);
          } else {
            verts.push(side.val, elev, i,   side.val, bottom, i,   side.val, elev, i+1);
            verts.push(side.val, elev, i+1,  side.val, bottom, i,   side.val, bottom, i+1);
          }
        }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
        geo.computeVertexNormals();
        const mesh = new THREE.Mesh(geo, skirtMat);
        mesh.name = 'terrain_skirt';
        group.add(mesh);
      }

      // Store cell type/texture info for tooltip raycasting
      group.userData.terrainType = terrainType;
      group.userData.textureArr = textureArr;

      // Store grid dimensions and elevation data for other builders
      group.userData.gridW = gridW;
      group.userData.gridH = gridH;
      group.userData.elevation = elevation;
      group.userData.texture = textureArr;
      return group;
    }

    // === PLACEABLE BUILDER ===
    function buildPlaceables(placed, getElev) {
      const group = new THREE.Group();
      group.name = 'placeables';
      if (!placed || !Array.isArray(placed)) return group;

      for (const item of placed) {
        const name = (item.name || item.template_name || item.prototype_name || '').toLowerCase();
        // Position is nested in places[0] from the blockchain
        const place = item.places?.[0] || {};
        const loc = place.location || item.location || {};
        const x = loc.x ?? 0;
        const z = loc.y ?? 0;
        const rot = ROTATION_MAP[place.grid_rotation || item.grid_rotation] || 0;

        // Compute footprint from relative_locations
        const rels = item.relative_locations || [{ x: 0, y: 0 }];
        let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
        for (const r of rels) {
          minX = Math.min(minX, r.x); maxX = Math.max(maxX, r.x);
          minZ = Math.min(minZ, r.y); maxZ = Math.max(maxZ, r.y);
        }
        const fw = maxX - minX + 1;
        const fd = maxZ - minZ + 1;

        const obj = buildPlaceableShape(name, fw, fd);
        const elev = getElev ? getElev(x + fw / 2 - 0.5, z + fd / 2 - 0.5) : 0;
        obj.position.set(x + fw / 2 - 0.5, elev, z + fd / 2 - 0.5);
        obj.rotation.y = rot;
        obj.userData.tooltipName = cleanPlaceableName(name);
        obj.userData.isPlotObject = true;
        group.add(obj);
      }

      return group;
    }

    function buildPlaceableShape(name, fw, fd) {
      const g = new THREE.Group();

      if (name.includes('fence')) {
        // Posts + rail
        const postColor = name.includes('blue') ? 0x3b82f6 : name.includes('red') ? 0xef4444 : 0xf5f5f0;
        const postGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.7, 6);
        const postMat = new THREE.MeshPhongMaterial({ color: 0x8B6914 });
        const post1 = new THREE.Mesh(postGeo, postMat);
        post1.position.set(-fw / 2 + 0.15, 0.35, 0);
        post1.castShadow = true;
        g.add(post1);
        const post2 = new THREE.Mesh(postGeo, postMat);
        post2.position.set(fw / 2 - 0.15, 0.35, 0);
        post2.castShadow = true;
        g.add(post2);
        const railGeo = new THREE.BoxGeometry(fw - 0.3, 0.06, 0.06);
        const railMat = new THREE.MeshPhongMaterial({ color: postColor });
        const rail1 = new THREE.Mesh(railGeo, railMat);
        rail1.position.set(0, 0.5, 0);
        g.add(rail1);
        const rail2 = new THREE.Mesh(railGeo, railMat);
        rail2.position.set(0, 0.25, 0);
        g.add(rail2);
      } else if (name.includes('wall_barrier') || name.includes('wallbarrier')) {
        const wallGeo = new THREE.BoxGeometry(fw * 0.9, 0.8, fd * 0.3);
        const wallMat = new THREE.MeshPhongMaterial({ color: 0x9ca3af });
        const wall = new THREE.Mesh(wallGeo, wallMat);
        wall.position.y = 0.4;
        wall.castShadow = true;
        g.add(wall);
      } else if (name.includes('wall_pillar') || name.includes('wallpillar')) {
        const pillarGeo = new THREE.CylinderGeometry(0.15, 0.18, 1.0, 8);
        const pillarMat = new THREE.MeshPhongMaterial({ color: 0x9ca3af });
        const pillar = new THREE.Mesh(pillarGeo, pillarMat);
        pillar.position.y = 0.5;
        pillar.castShadow = true;
        g.add(pillar);
        const capGeo = new THREE.BoxGeometry(0.4, 0.08, 0.4);
        const cap = new THREE.Mesh(capGeo, pillarMat);
        cap.position.y = 1.04;
        g.add(cap);
      } else if (name.includes('craftingstation')) {
        // Table base
        const tableGeo = new THREE.BoxGeometry(fw * 0.8, 0.5, fd * 0.8);
        const tableMat = new THREE.MeshPhongMaterial({ color: 0x92400e });
        const table = new THREE.Mesh(tableGeo, tableMat);
        table.position.y = 0.25;
        table.castShadow = true;
        g.add(table);
        // Top accessory
        if (name.includes('tool') || name.includes('anvil')) {
          const anvilGeo = new THREE.BoxGeometry(0.3, 0.15, 0.2);
          const anvilMat = new THREE.MeshPhongMaterial({ color: 0x374151 });
          const anvil = new THREE.Mesh(anvilGeo, anvilMat);
          anvil.position.y = 0.58;
          g.add(anvil);
        } else if (name.includes('dispenser') || name.includes('seed')) {
          const cylGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.25, 8);
          const cylMat = new THREE.MeshPhongMaterial({ color: 0x059669 });
          const cyl = new THREE.Mesh(cylGeo, cylMat);
          cyl.position.y = 0.63;
          g.add(cyl);
        } else {
          const topGeo = new THREE.BoxGeometry(0.35, 0.1, 0.35);
          const topMat = new THREE.MeshPhongMaterial({ color: 0xb45309 });
          const top = new THREE.Mesh(topGeo, topMat);
          top.position.y = 0.55;
          g.add(top);
        }
      } else if (name.includes('homestead') || name.includes('house')) {
        // House base
        const baseGeo = new THREE.BoxGeometry(fw * 0.85, 1.0, fd * 0.85);
        const baseMat = new THREE.MeshPhongMaterial({ color: 0xf5deb3 });
        const base = new THREE.Mesh(baseGeo, baseMat);
        base.position.y = 0.5;
        base.castShadow = true;
        g.add(base);
        // Roof
        const roofGeo = new THREE.ConeGeometry(Math.max(fw, fd) * 0.6, 0.6, 4);
        const roofMat = new THREE.MeshPhongMaterial({ color: 0x8B0000 });
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.position.y = 1.3;
        roof.rotation.y = Math.PI / 4;
        roof.castShadow = true;
        g.add(roof);
        // Door
        const doorGeo = new THREE.BoxGeometry(0.2, 0.4, 0.05);
        const doorMat = new THREE.MeshPhongMaterial({ color: 0x5c3317 });
        const door = new THREE.Mesh(doorGeo, doorMat);
        door.position.set(0, 0.2, fd * 0.43);
        g.add(door);
        // Chimney
        const chimGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.4, 6);
        const chimMat = new THREE.MeshPhongMaterial({ color: 0x6b7280 });
        const chim = new THREE.Mesh(chimGeo, chimMat);
        chim.position.set(fw * 0.25, 1.5, -fd * 0.15);
        g.add(chim);
      } else if (name.includes('tree') || name.includes('bush')) {
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.12, 0.6, 6),
          new THREE.MeshPhongMaterial({ color: 0x8B4513 })
        );
        trunk.position.y = 0.3;
        trunk.castShadow = true;
        g.add(trunk);
        const canopy = new THREE.Mesh(
          new THREE.IcosahedronGeometry(name.includes('bush') ? 0.3 : 0.45, 1),
          new THREE.MeshPhongMaterial({ color: 0x228B22 })
        );
        canopy.position.y = name.includes('bush') ? 0.5 : 0.85;
        canopy.castShadow = true;
        g.add(canopy);
      } else if (name.includes('lamp') || name.includes('lantern')) {
        const poleGeo = new THREE.CylinderGeometry(0.03, 0.04, 0.9, 6);
        const poleMat = new THREE.MeshPhongMaterial({ color: 0x374151 });
        const pole = new THREE.Mesh(poleGeo, poleMat);
        pole.position.y = 0.45;
        pole.castShadow = true;
        g.add(pole);
        const bulbGeo = new THREE.SphereGeometry(0.1, 8, 8);
        const bulbMat = new THREE.MeshPhongMaterial({ color: 0xfef08a, emissive: 0xfbbf24, emissiveIntensity: 0.6 });
        const bulb = new THREE.Mesh(bulbGeo, bulbMat);
        bulb.position.y = 0.95;
        g.add(bulb);
      } else if (name.includes('storage') || name.includes('chest')) {
        const chestGeo = new THREE.BoxGeometry(fw * 0.7, 0.35, fd * 0.5);
        const chestMat = new THREE.MeshPhongMaterial({ color: 0x92400e });
        const chest = new THREE.Mesh(chestGeo, chestMat);
        chest.position.y = 0.175;
        chest.castShadow = true;
        g.add(chest);
        const lidGeo = new THREE.BoxGeometry(fw * 0.72, 0.04, fd * 0.12);
        const lidMat = new THREE.MeshPhongMaterial({ color: 0xb45309 });
        const lid = new THREE.Mesh(lidGeo, lidMat);
        lid.position.set(0, 0.36, 0);
        g.add(lid);
      } else {
        // Default colored box
        const boxGeo = new THREE.BoxGeometry(fw * 0.8, 0.5, fd * 0.8);
        // Deterministic color from name
        const hash = name.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
        const hue = (hash * 137) % 360;
        const color = new THREE.Color().setHSL(hue / 360, 0.5, 0.45);
        const boxMat = new THREE.MeshPhongMaterial({ color });
        const box = new THREE.Mesh(boxGeo, boxMat);
        box.position.y = 0.25;
        box.castShadow = true;
        g.add(box);
      }

      return g;
    }

    // === FARMING BUILDER ===
    function buildFarming(farmingCells, getElev) {
      const group = new THREE.Group();
      group.name = 'farming';
      if (!farmingCells || !Array.isArray(farmingCells)) return group;

      // Group by visual state
      const tilled = [];
      const growing = [];
      const mature = [];

      for (const cell of farmingCells) {
        const loc = cell.location || {};
        const gx = loc.x ?? 0;
        const gz = loc.y ?? 0;
        const cropName = cell.plant?.name ? cell.plant.name.replace(/^seed_/, '').replace(/_/g, ' ') : '';
        const entry = { x: gx, z: gz, elev: getElev ? getElev(gx, gz) : 0, cell, cropName };
        if (cell.plant && cell.current_state === 'mature') {
          mature.push(entry);
        } else if (cell.plant) {
          // Both 'planted' and 'growing' states show as growing
          growing.push(entry);
        } else {
          tilled.push(entry);
        }
      }

      const dummy = new THREE.Object3D();

      // Tilled soil (empty)
      if (tilled.length > 0) {
        const geo = new THREE.BoxGeometry(0.8, 0.05, 0.8);
        const mat = new THREE.MeshPhongMaterial({ color: 0x5c3317 });
        const mesh = new THREE.InstancedMesh(geo, mat, tilled.length);
        mesh.name = 'farming_tilled';
        tilled.forEach((t, i) => {
          dummy.position.set(t.x, t.elev + 0.025, t.z);
          dummy.updateMatrix();
          mesh.setMatrixAt(i, dummy.matrix);
        });
        mesh.instanceMatrix.needsUpdate = true;
        mesh.receiveShadow = true;
        group.add(mesh);
      }

      // Growing (soil + small green sprout)
      if (growing.length > 0) {
        // Soil
        const soilGeo = new THREE.BoxGeometry(0.8, 0.05, 0.8);
        const soilMat = new THREE.MeshPhongMaterial({ color: 0x5c3317 });
        const soilMesh = new THREE.InstancedMesh(soilGeo, soilMat, growing.length);
        soilMesh.name = 'farming_growing_soil';
        growing.forEach((t, i) => {
          dummy.position.set(t.x, t.elev + 0.025, t.z);
          dummy.updateMatrix();
          soilMesh.setMatrixAt(i, dummy.matrix);
        });
        soilMesh.instanceMatrix.needsUpdate = true;
        soilMesh.receiveShadow = true;
        group.add(soilMesh);

        // Sprouts
        const sproutGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.25, 6);
        const sproutMat = new THREE.MeshPhongMaterial({ color: 0x22c55e });
        const sproutMesh = new THREE.InstancedMesh(sproutGeo, sproutMat, growing.length);
        sproutMesh.name = 'farming_growing_sprout';
        growing.forEach((t, i) => {
          dummy.position.set(t.x, t.elev + 0.175, t.z);
          dummy.updateMatrix();
          sproutMesh.setMatrixAt(i, dummy.matrix);
        });
        sproutMesh.instanceMatrix.needsUpdate = true;
        sproutMesh.castShadow = true;
        group.add(sproutMesh);
      }

      // Mature (soil + tall plant + fruit sphere)
      if (mature.length > 0) {
        // Soil
        const soilGeo = new THREE.BoxGeometry(0.8, 0.05, 0.8);
        const soilMat = new THREE.MeshPhongMaterial({ color: 0x5c3317 });
        const soilMesh = new THREE.InstancedMesh(soilGeo, soilMat, mature.length);
        soilMesh.name = 'farming_mature_soil';
        mature.forEach((t, i) => {
          dummy.position.set(t.x, t.elev + 0.025, t.z);
          dummy.updateMatrix();
          soilMesh.setMatrixAt(i, dummy.matrix);
        });
        soilMesh.instanceMatrix.needsUpdate = true;
        soilMesh.receiveShadow = true;
        group.add(soilMesh);

        // Stems
        const stemGeo = new THREE.CylinderGeometry(0.04, 0.05, 0.45, 6);
        const stemMat = new THREE.MeshPhongMaterial({ color: 0x16a34a });
        const stemMesh = new THREE.InstancedMesh(stemGeo, stemMat, mature.length);
        stemMesh.name = 'farming_mature_stem';
        mature.forEach((t, i) => {
          dummy.position.set(t.x, t.elev + 0.275, t.z);
          dummy.updateMatrix();
          stemMesh.setMatrixAt(i, dummy.matrix);
        });
        stemMesh.instanceMatrix.needsUpdate = true;
        stemMesh.castShadow = true;
        group.add(stemMesh);

        // Fruits
        const fruitGeo = new THREE.SphereGeometry(0.1, 8, 8);
        const fruitMat = new THREE.MeshPhongMaterial({ color: 0xef4444 });
        const fruitMesh = new THREE.InstancedMesh(fruitGeo, fruitMat, mature.length);
        fruitMesh.name = 'farming_mature_fruit';
        mature.forEach((t, i) => {
          dummy.position.set(t.x, t.elev + 0.55, t.z);
          dummy.updateMatrix();
          fruitMesh.setMatrixAt(i, dummy.matrix);
        });
        fruitMesh.instanceMatrix.needsUpdate = true;
        fruitMesh.castShadow = true;
        group.add(fruitMesh);
      }

      return group;
    }

    // === RESOURCE NODE BUILDER ===
    function buildResourceNodes(nodes, getElev) {
      const group = new THREE.Group();
      group.name = 'resourceNodes';
      if (!nodes || !Array.isArray(nodes)) return group;

      for (const node of nodes) {
        const proto = (node.node_prototype_name || '').toLowerCase();
        const loc = node.location || {};
        const x = loc.x ?? 0;
        const z = loc.y ?? 0;
        const rot = ROTATION_MAP[node.rotation] || 0;

        // Parse type and tier: resourcenode_{type}_t{tier} or economynode_{type}
        const resMatch = proto.match(/resourcenode_(\w+?)_t(\d+)/);
        const econMatch = proto.match(/economynode_(\w+)/);

        let obj, tooltipName;
        if (resMatch) {
          const type = resMatch[1];
          const tier = parseInt(resMatch[2]);
          const scale = tier === 1 ? 0.7 : tier === 2 ? 1.0 : 1.3;
          obj = buildNodeShape(type, scale);
          tooltipName = `${type.charAt(0).toUpperCase() + type.slice(1)} T${tier}`;
        } else if (econMatch) {
          const econType = econMatch[1];
          obj = buildEconomyNodeShape(econType);
          tooltipName = `${econType.charAt(0).toUpperCase() + econType.slice(1)} Spot`;
        } else {
          obj = buildNodeShape('unknown', 0.7);
          tooltipName = proto || 'Unknown Node';
        }

        const elev = getElev ? getElev(x, z) : 0;
        obj.position.set(x, elev, z);
        obj.rotation.y = rot;
        obj.userData.tooltipName = tooltipName;
        obj.userData.isPlotObject = true;
        group.add(obj);
      }

      return group;
    }

    function buildNodeShape(type, scale) {
      const g = new THREE.Group();

      if (type === 'wood') {
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1 * scale, 0.15 * scale, 0.8 * scale, 6),
          new THREE.MeshPhongMaterial({ color: 0x8B4513 })
        );
        trunk.position.y = 0.4 * scale;
        trunk.castShadow = true;
        g.add(trunk);
        const canopy = new THREE.Mesh(
          new THREE.ConeGeometry(0.35 * scale, 0.7 * scale, 8),
          new THREE.MeshPhongMaterial({ color: 0x14532d })
        );
        canopy.position.y = 1.0 * scale;
        canopy.castShadow = true;
        g.add(canopy);
      } else if (type === 'stone') {
        const rock = new THREE.Mesh(
          new THREE.DodecahedronGeometry(0.3 * scale, 0),
          new THREE.MeshPhongMaterial({ color: 0x9ca3af, flatShading: true })
        );
        rock.position.y = 0.25 * scale;
        rock.castShadow = true;
        g.add(rock);
      } else if (type === 'ore') {
        const crystal = new THREE.Mesh(
          new THREE.OctahedronGeometry(0.25 * scale, 0),
          new THREE.MeshPhongMaterial({ color: 0x475569, flatShading: true, shininess: 80 })
        );
        crystal.position.y = 0.3 * scale;
        crystal.rotation.set(0.2, 0.4, 0.1);
        crystal.castShadow = true;
        g.add(crystal);
      } else if (type === 'fiber') {
        // Cluster of thin reeds
        for (let i = 0; i < 5; i++) {
          const reed = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02 * scale, 0.03 * scale, 0.5 * scale, 4),
            new THREE.MeshPhongMaterial({ color: 0x86efac })
          );
          const angle = (i / 5) * Math.PI * 2;
          reed.position.set(
            Math.cos(angle) * 0.1 * scale,
            0.25 * scale,
            Math.sin(angle) * 0.1 * scale
          );
          reed.rotation.x = (Math.random() - 0.5) * 0.15;
          reed.rotation.z = (Math.random() - 0.5) * 0.15;
          reed.castShadow = true;
          g.add(reed);
        }
      } else if (type === 'sediment') {
        const mound = new THREE.Mesh(
          new THREE.BoxGeometry(0.5 * scale, 0.15 * scale, 0.5 * scale),
          new THREE.MeshPhongMaterial({ color: 0xd4a574 })
        );
        mound.position.y = 0.075 * scale;
        mound.receiveShadow = true;
        g.add(mound);
      } else {
        // Unknown type ‚Äî small sphere
        const orb = new THREE.Mesh(
          new THREE.SphereGeometry(0.2 * scale, 8, 8),
          new THREE.MeshPhongMaterial({ color: 0xfbbf24 })
        );
        orb.position.y = 0.2 * scale;
        g.add(orb);
      }

      return g;
    }

    function buildEconomyNodeShape(econType) {
      const g = new THREE.Group();
      if (econType === 'fishing') {
        // Fishing spot: small dock/pier + water ripple
        const pier = new THREE.Mesh(
          new THREE.BoxGeometry(0.6, 0.08, 0.3),
          new THREE.MeshPhongMaterial({ color: 0x8B6914 })
        );
        pier.position.y = 0.15;
        g.add(pier);
        const post = new THREE.Mesh(
          new THREE.CylinderGeometry(0.03, 0.03, 0.5, 6),
          new THREE.MeshPhongMaterial({ color: 0x8B4513 })
        );
        post.position.set(0.2, 0.35, 0);
        g.add(post);
        // Fishing line
        const line = new THREE.Mesh(
          new THREE.CylinderGeometry(0.005, 0.005, 0.3, 4),
          new THREE.MeshPhongMaterial({ color: 0xcccccc })
        );
        line.position.set(0.25, 0.2, 0.1);
        line.rotation.z = 0.8;
        g.add(line);
        // Water ripple ring
        const ring = new THREE.Mesh(
          new THREE.RingGeometry(0.15, 0.2, 16),
          new THREE.MeshPhongMaterial({ color: 0x60a5fa, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
        );
        ring.rotation.x = -Math.PI / 2;
        ring.position.set(0, 0.02, 0);
        g.add(ring);
      } else if (econType === 'farming') {
        // Farming spot: soil patch with seed bag
        const soil = new THREE.Mesh(
          new THREE.BoxGeometry(0.7, 0.06, 0.7),
          new THREE.MeshPhongMaterial({ color: 0x5c3317 })
        );
        soil.position.y = 0.03;
        g.add(soil);
        const bag = new THREE.Mesh(
          new THREE.BoxGeometry(0.15, 0.2, 0.1),
          new THREE.MeshPhongMaterial({ color: 0xd4a574 })
        );
        bag.position.set(0.2, 0.13, 0.2);
        g.add(bag);
      } else if (econType === 'crafting') {
        // Crafting spot: workbench with tools
        const bench = new THREE.Mesh(
          new THREE.BoxGeometry(0.6, 0.4, 0.4),
          new THREE.MeshPhongMaterial({ color: 0x92400e })
        );
        bench.position.y = 0.2;
        g.add(bench);
        const anvil = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.12, 0.15),
          new THREE.MeshPhongMaterial({ color: 0x4b5563 })
        );
        anvil.position.set(0, 0.46, 0);
        g.add(anvil);
      } else {
        // Generic economy node
        const orb = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 8, 8),
          new THREE.MeshPhongMaterial({ color: 0xfbbf24, emissive: 0xfbbf24, emissiveIntensity: 0.3 })
        );
        orb.position.y = 0.2;
        g.add(orb);
      }
      return g;
    }

    // === ENTER PLOT VIEW ===
    function enterPlotView(data, land) {
      if (viewMode === 'plot') exitPlotView();
      viewMode = 'plot';
      currentPlotData = data;

      // Save camera state
      savedCameraState = {
        position: camera.position.clone(),
        target: controls.target.clone(),
        minDist: controls.minDistance,
        maxDist: controls.maxDistance,
        maxPolar: controls.maxPolarAngle,
      };

      // Hide all world objects (keep sky, lights, stars)
      hiddenWorldObjects = [];
      scene.children.forEach(child => {
        if (child === sky || child === stars || child instanceof THREE.Light) return;
        if (child.visible) {
          hiddenWorldObjects.push(child);
          child.visible = false;
        }
      });

      // Build plot scene
      plotViewGroup = new THREE.Group();
      plotViewGroup.name = 'plotView';

      const terrain = buildTerrain(data.map);
      plotViewGroup.add(terrain);
      const elevData = terrain.userData.elevation;
      const tGridW = terrain.userData.gridW || 100;
      const elevScale = 0.08;
      const getElev = (gx, gz) => {
        const idx = Math.floor(gz) * tGridW + Math.floor(gx);
        return (elevData && idx >= 0 && idx < elevData.length) ? elevData[idx] * elevScale : 0;
      };
      plotViewGroup.add(buildPlaceables(data.placeables?.placed, getElev));
      plotViewGroup.add(buildFarming(data.farming, getElev));
      plotViewGroup.add(buildResourceNodes(data.nodes, getElev));

      scene.add(plotViewGroup);

      // Camera: isometric view over plot center
      const gridW = terrain.userData.gridW || 100;
      const gridH = terrain.userData.gridH || 200;
      const centerX = gridW / 2;
      const centerZ = gridH / 2;
      const extent = Math.max(gridW, gridH);

      // Adjust controls for plot view
      controls.minDistance = 10;
      controls.maxDistance = extent * 1.5;
      controls.maxPolarAngle = Math.PI / 2.05;

      // Animate camera
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const endTarget = new THREE.Vector3(centerX, 0, centerZ);
      const endPos = new THREE.Vector3(centerX + extent * 0.4, extent * 0.35, centerZ + extent * 0.4);
      const duration = 800;
      const startTime = Date.now();

      function animateIn() {
        const elapsed = Date.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - t, 3);
        camera.position.lerpVectors(startPos, endPos, eased);
        controls.target.lerpVectors(startTarget, endTarget, eased);
        if (t < 1) requestAnimationFrame(animateIn);
      }
      animateIn();

      // Show back button, hide world UI
      document.getElementById('back-to-world').style.display = 'block';
      document.getElementById('info').style.display = 'none';
      document.getElementById('stats').style.display = 'none';
      document.getElementById('legend').style.display = 'none';
      document.getElementById('land-info').style.display = 'none';
      const chainStats = document.getElementById('chain-stats');
      if (chainStats) chainStats.style.display = 'none';
      const storefront = document.getElementById('storefront');
      if (storefront) storefront.style.display = 'none';
      const fieldGuide = document.getElementById('field-guide');
      if (fieldGuide) fieldGuide.style.display = 'none';
      const leaderboard = document.getElementById('leaderboard');
      if (leaderboard) leaderboard.style.display = 'none';
      const playerSearch = document.getElementById('player-search');
      if (playerSearch) playerSearch.style.display = 'none';
    }

    // === EXIT PLOT VIEW ===
    function exitPlotView() {
      if (viewMode !== 'plot') return;

      // Remove and dispose plot group
      if (plotViewGroup) {
        plotViewGroup.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
            else child.material.dispose();
          }
        });
        scene.remove(plotViewGroup);
        plotViewGroup = null;
      }

      // Restore world objects
      hiddenWorldObjects.forEach(obj => { obj.visible = true; });
      hiddenWorldObjects = [];

      // Restore camera
      if (savedCameraState) {
        const startPos = camera.position.clone();
        const startTarget = controls.target.clone();
        const duration = 800;
        const startTime = Date.now();

        controls.minDistance = savedCameraState.minDist;
        controls.maxDistance = savedCameraState.maxDist;
        controls.maxPolarAngle = savedCameraState.maxPolar;

        function animateOut() {
          const elapsed = Date.now() - startTime;
          const t = Math.min(elapsed / duration, 1);
          const eased = 1 - Math.pow(1 - t, 3);
          camera.position.lerpVectors(startPos, savedCameraState.position, eased);
          controls.target.lerpVectors(startTarget, savedCameraState.target, eased);
          if (t < 1) requestAnimationFrame(animateOut);
        }
        animateOut();
        savedCameraState = null;
      }

      viewMode = 'world';
      currentPlotData = null;

      // Restore world UI
      document.getElementById('back-to-world').style.display = 'none';
      document.getElementById('plot-tooltip').style.display = 'none';
      document.getElementById('info').style.display = 'block';
      document.getElementById('stats').style.display = 'block';
      document.getElementById('legend').style.display = 'block';
      if (selectedLand) document.getElementById('land-info').style.display = 'block';
      const chainStats = document.getElementById('chain-stats');
      if (chainStats) chainStats.style.display = 'block';
      const storefront = document.getElementById('storefront');
      if (storefront) storefront.style.display = 'block';
      const fieldGuide = document.getElementById('field-guide');
      if (fieldGuide) fieldGuide.style.display = 'block';
      const leaderboard = document.getElementById('leaderboard');
      if (leaderboard) leaderboard.style.display = 'block';
      const playerSearch = document.getElementById('player-search');
      if (playerSearch) playerSearch.style.display = 'block';
    }

    // Back button
    document.getElementById('back-to-world').addEventListener('click', exitPlotView);

    // === PLOT VIEW HOVER TOOLTIP ===
    window.addEventListener('mousemove', (event) => {
      if (viewMode !== 'plot' || !plotViewGroup) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(plotViewGroup.children, true);
      const tooltip = document.getElementById('plot-tooltip');

      // Walk up to find a group with tooltipName
      const terrainTypeMap = {
        0: 'Deep Water', 1: 'Grass', 2: 'Dirt', 3: 'Sand', 4: 'Meadow', 5: 'Fertile Soil',
        6: 'Rocky Ground', 7: 'Mud', 8: 'Shallow Water', 9: 'Gravel', 10: 'Stone',
        11: 'Dense Vegetation', 12: 'Path', 13: 'Forest Floor', 14: 'Deep River',
        15: 'Dry Sand', 16: 'Dark Stone', 17: 'Clay', 18: 'Moss', 19: 'Dried Earth',
        20: 'Pale Grass', 21: 'Dark Rock', 22: 'Scrubland', 23: 'Pond', 24: 'Loam',
        25: 'Sandstone', 26: 'Fern Ground', 27: 'Chalk', 28: 'Packed Earth', 29: 'Slate',
        30: 'Forest Moss', 31: 'Dune', 32: 'Silt', 33: 'Undergrowth', 34: 'Tidal Pool',
        35: 'Red Earth', 36: 'Clover', 37: 'Dry Grass', 38: 'Flagstone', 39: 'Ivy Ground',
        41: 'Sage Grass', 43: 'Rose Earth', 44: 'Boulder', 45: 'Stream', 46: 'Dark Cliff',
        47: 'Golden Sand', 48: 'Lagoon', 49: 'Peat', 50: 'Fresh Sprout',
      };
      const texTypeNames = { 1: 'Paved', 2: 'Path', 3: 'Garden' };

      let name = null;
      for (const hit of intersects) {
        let obj = hit.object;
        while (obj) {
          if (obj.userData && obj.userData.tooltipName) {
            name = obj.userData.tooltipName;
            break;
          }
          // Check terrain plane ‚Äî use hit point to find grid cell
          if (obj.name === 'terrain_plane' && hit.point) {
            const gx = Math.round(hit.point.x);
            const gz = Math.round(hit.point.z);
            const terrainGroup = plotViewGroup.children.find(c => c.name === 'terrain');
            if (terrainGroup && terrainGroup.userData.terrainType) {
              const gw = terrainGroup.userData.gridW || 100;
              const cellIdx = gz * gw + gx;
              const tType = terrainGroup.userData.terrainType;
              const tTex = terrainGroup.userData.textureArr;
              if (cellIdx >= 0 && cellIdx < tType.length) {
                const typeNum = tType[cellIdx];
                const texNum = (tTex && cellIdx < tTex.length) ? tTex[cellIdx] : 0;
                const terrainName = terrainTypeMap[typeNum] || `Terrain ${typeNum}`;
                name = texNum > 0 ? `${terrainName} (${texTypeNames[texNum] || 'Decorated'})` : terrainName;
              }
            }
            if (!name) name = 'Terrain';
            break;
          }
          if (obj.name && obj.name.startsWith('farming_')) {
            // Try to get crop info from the farming data
            if (obj.name.includes('mature')) {
              name = 'Mature Crop';
            } else if (obj.name.includes('growing')) {
              name = 'Growing Crop';
            } else {
              name = 'Tilled Soil';
            }
            // Enhance with grid position if possible
            if (hit.instanceId !== undefined && currentPlotData?.farming) {
              const state = obj.name.includes('mature') ? 'mature' : obj.name.includes('growing') ? 'growing' : 'tilled';
              const cells = (currentPlotData.farming || []).filter(c => {
                if (state === 'mature') return c.plant && c.current_state === 'mature';
                if (state === 'growing') return c.plant && c.current_state !== 'mature';
                return !c.plant;
              });
              if (cells[hit.instanceId]) {
                const cell = cells[hit.instanceId];
                const cropName = cell.plant?.name ? cell.plant.name.replace(/^seed_/, '').replace(/_/g, ' ') : '';
                if (cropName) name = `${name}: ${cropName}`;
                if (cell.fertile) name += ' (fertile)';
              }
            }
            break;
          }
          obj = obj.parent;
        }
        if (name) break;
      }

      if (name) {
        tooltip.textContent = name;
        tooltip.style.display = 'block';
        tooltip.style.left = (event.clientX + 14) + 'px';
        tooltip.style.top = (event.clientY + 14) + 'px';
      } else {
        tooltip.style.display = 'none';
      }
    });

    // Zoom to a specific land
    function zoomToLand(land) {
      if (!land) return;

      const targetX = land.x;
      const targetZ = land.y;

      // Animate camera to the land
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const endTarget = new THREE.Vector3(targetX, 0, targetZ);
      const endPos = new THREE.Vector3(targetX + 5, 8, targetZ + 5);

      const duration = 1000;
      const startTime = Date.now();

      function animateZoom() {
        const elapsed = Date.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        // Ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);

        camera.position.lerpVectors(startPos, endPos, eased);
        controls.target.lerpVectors(startTarget, endTarget, eased);

        if (t < 1) {
          requestAnimationFrame(animateZoom);
        }
      }
      animateZoom();
    }

    // Toast notification
    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2000);
    }

    // Set up button handlers
    document.getElementById('zoom-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      if (selectedLand) {
        zoomToLand(selectedLand);
      }
    });


    function onMouseClick(event) {
      if (viewMode === 'plot') return; // Ignore in plot view
      // Ignore clicks on UI panels
      if (event.target.closest('.draggable-panel') || event.target.closest('#land-info') || event.target.closest('#info') || event.target.closest('#stats')) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(landMeshes);

      if (selectedMesh) {
        selectedMesh.material.emissive.setHex(0x000000);
      }

      if (intersects.length > 0) {
        const mesh = intersects[0].object;
        const landId = mesh.userData.landId;
        const land = landDataMap.get(landId);

        if (land) {
          selectedMesh = mesh;
          selectedLand = land;
          mesh.material.emissive.setHex(0x333333);

          // Update info panel
          document.getElementById('land-name').textContent = land.name;
          document.getElementById('plot-id').textContent = `Plot #${land.plotId || land.id}`;
          document.getElementById('land-island').textContent = land.island || 'Unknown';
          document.getElementById('land-region').textContent = land.region || 'Unknown';
          document.getElementById('land-coords').textContent = `(${land.realX || land.x}, ${land.realY || land.y})`;
          document.getElementById('land-biome').textContent = (land.biome || 'plains').charAt(0).toUpperCase() + (land.biome || 'plains').slice(1);
          document.getElementById('land-soil').textContent = `Soil: ${land.soilType || 'unknown'}`;
          document.getElementById('land-water').textContent = `Water: ${land.waterType || 'unknown'}`;

          const saleDiv = document.getElementById('land-sale');
          if (land.forSale && land.price) {
            saleDiv.style.display = 'block';
            document.getElementById('land-price').textContent = land.price.toFixed(2);
            document.getElementById('land-seller').textContent = land.seller || 'Unknown';
          } else {
            saleDiv.style.display = 'none';
          }

          // Update MNA map link (no deep linking available, just opens map)
          const mapBtn = document.getElementById('map-btn');
          mapBtn.href = 'https://myneighboralice.com/map/';
          const coords = `(${land.realX || land.x}, ${land.realY || land.y})`;
          mapBtn.title = `Open MNA map ‚Äî navigate to ${coords}`;

          document.getElementById('land-info').style.display = 'block';
          document.getElementById('plot-deep-dive').style.display = 'none';
          document.getElementById('dblclick-hint').style.display = 'block';
          console.log('Selected land:', land);
        }
      } else {
        document.getElementById('land-info').style.display = 'none';
        document.getElementById('plot-deep-dive').style.display = 'none';
        document.getElementById('dblclick-hint').style.display = 'none';
        selectedMesh = null;
        selectedLand = null;
      }
    }

    // Use timer to distinguish single-click from double-click
    let clickTimer = null;
    let suppressClick = false;

    window.addEventListener('click', (event) => {
      if (suppressClick) return;
      // Delay single-click handling to allow dblclick to cancel it
      if (clickTimer) clearTimeout(clickTimer);
      clickTimer = setTimeout(() => {
        clickTimer = null;
        onMouseClick(event);
      }, 250);
    }, false);

    // Double-click to zoom + show deep-dive details
    window.addEventListener('dblclick', (event) => {
      // Cancel any pending single-click
      if (clickTimer) { clearTimeout(clickTimer); clickTimer = null; }
      if (viewMode === 'plot') return; // Ignore in plot view
      if (event.target.closest('.draggable-panel') || event.target.closest('#land-info') || event.target.closest('#info') || event.target.closest('#stats') || event.target.closest('#back-to-world')) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(landMeshes);

      if (intersects.length > 0) {
        const landId = intersects[0].object.userData.landId;
        const land = landDataMap.get(landId);
        if (!land) return;

        // Zoom camera to tile
        zoomToLand(land);

        // Select the tile if not already selected
        if (selectedMesh) selectedMesh.material.emissive.setHex(0x000000);
        selectedMesh = intersects[0].object;
        selectedLand = land;
        selectedMesh.material.emissive.setHex(0x333333);

        const plotId = land.plotId || land.id;

        // Show info panel
        document.getElementById('land-name').textContent = land.name;
        document.getElementById('plot-id').textContent = `Plot #${plotId}`;
        document.getElementById('land-island').textContent = land.island || 'Unknown';
        document.getElementById('land-region').textContent = land.region || 'Unknown';
        document.getElementById('land-coords').textContent = `(${land.realX || land.x}, ${land.realY || land.y})`;
        document.getElementById('land-biome').textContent = (land.biome || 'plains').charAt(0).toUpperCase() + (land.biome || 'plains').slice(1);
        document.getElementById('land-soil').textContent = `Soil: ${land.soilType || 'unknown'}`;
        document.getElementById('land-water').textContent = `Water: ${land.waterType || 'unknown'}`;
        document.getElementById('land-info').style.display = 'block';

        // Hide hint, show deep dive loading
        document.getElementById('dblclick-hint').style.display = 'none';
        const deepDive = document.getElementById('plot-deep-dive');
        deepDive.style.display = 'block';
        document.getElementById('plot-meta').textContent = 'Loading...';
        document.getElementById('plot-farming').textContent = 'Loading...';
        document.getElementById('plot-fishing').textContent = 'Loading...';
        document.getElementById('plot-nodes').textContent = 'Loading...';
        document.getElementById('plot-placeables').textContent = 'Loading...';
        document.getElementById('plot-avatar').textContent = 'Loading...';
        document.getElementById('plot-map').textContent = 'Loading...';

        // Fetch deep-dive data from Chromia
        fetch(`/api/v1/plots/${plotId}`)
          .then(r => r.json())
          .then(data => {
            if (!data.success) { deepDive.style.display = 'none'; return; }

            // Enter 3D plot view if terrain data available
            if (data.map && data.map.cells) {
              enterPlotView(data, land);
            }

            // Plot metadata
            if (data.meta) {
              const m = data.meta;
              const parts = [];
              if (m.owner_name) parts.push(`Owner: ${m.owner_name}`);
              if (m.plot_name) parts.push(`Name: ${m.plot_name}`);
              if (m.region_name) parts.push(`Region: ${m.region_name}`);
              if (m.biome) parts.push(`Biome: ${m.biome}`);
              if (m.level != null) parts.push(`Level: ${m.level}`);
              document.getElementById('plot-meta').innerHTML = parts.length > 0
                ? parts.map(p => `<div>${p}</div>`).join('')
                : 'No metadata available';
            } else {
              document.getElementById('plot-meta').textContent = 'No metadata available';
            }

            // Farming
            if (data.farming && data.farming.length > 0) {
              const mature = data.farming.filter(f => f.current_state === 'mature').length;
              const growing = data.farming.filter(f => f.plant && f.current_state !== 'mature').length;
              const empty = data.farming.filter(f => !f.plant).length;
              const plantNames = [...new Set(data.farming.filter(f => f.plant).map(f => f.plant.name.replace('seed_', '').replace(/_/g, ' ')))];
              let html = `${data.farming.length} plots: ${mature} mature, ${growing} growing, ${empty} empty`;
              if (plantNames.length > 0) html += `<br><small style="color:#888">Growing: ${plantNames.join(', ')}</small>`;
              document.getElementById('plot-farming').innerHTML = html;
            } else {
              document.getElementById('plot-farming').textContent = 'No crops planted';
            }

            // Fishing
            if (data.fishing && data.fishing.length > 0) {
              const names = data.fishing.map(f => f.name.replace('fish_', '').replace(/_/g, ' '));
              document.getElementById('plot-fishing').innerHTML =
                `${names.length} species available<br><small style="color:#888">${names.join(', ')}</small>`;
            } else {
              document.getElementById('plot-fishing').textContent = 'No fish data';
            }

            // Resource nodes
            if (data.nodes && data.nodes.length > 0) {
              const groups = {};
              data.nodes.forEach(n => {
                const type = n.node_prototype_name.replace('resourcenode_', '').replace(/_t\d+/, '').replace(/_/g, ' ');
                groups[type] = (groups[type] || 0) + 1;
              });
              const summary = Object.entries(groups).map(([k,v]) => `${v}x ${k}`).join(', ');
              document.getElementById('plot-nodes').innerHTML =
                `${data.nodes.length} resource nodes<br><small style="color:#888">${summary}</small>`;
            } else {
              document.getElementById('plot-nodes').textContent = 'No resource nodes';
            }

            // Placeables
            if (data.placeables) {
              const cleanName = (name) => name
                .replace(/^(placeable_|equippable_|seed_|fish_|resourcenode_|craftingstation_)/, '')
                .replace(/_/g, ' ')
                .replace(/\b\w/g, c => c.toUpperCase());
              const pl = data.placeables;
              if (pl.placedCount > 0 || pl.inventory.length > 0) {
                let html = `${pl.placedCount} item${pl.placedCount !== 1 ? 's' : ''} placed on plot`;
                if (pl.inventory.length > 0) {
                  const items = pl.inventory
                    .sort((a, b) => b.amount - a.amount)
                    .slice(0, 12)
                    .map(i => `${cleanName(i.name)} x${i.amount}`)
                    .join(', ');
                  html += `<br><small style="color:#888">Inventory: ${items}${pl.inventory.length > 12 ? '...' : ''}</small>`;
                }
                document.getElementById('plot-placeables').innerHTML = html;
              } else {
                document.getElementById('plot-placeables').textContent = 'No placeables';
              }
            } else {
              document.getElementById('plot-placeables').textContent = 'No placeables data';
            }

            // Avatar
            if (data.avatar && data.avatar.equippables && data.avatar.equippables.length > 0) {
              const cleanName = (name) => name
                .replace(/^(placeable_|equippable_|seed_|fish_|resourcenode_|hair_|craftingstation_)/, '')
                .replace(/_/g, ' ')
                .replace(/\b\w/g, c => c.toUpperCase());
              const items = data.avatar.equippables.map(e => cleanName(e.name)).join(', ');
              document.getElementById('plot-avatar').innerHTML =
                `Wearing: <small style="color:#888">${items}</small>`;
            } else {
              document.getElementById('plot-avatar').textContent = 'No avatar data';
            }

            // Terrain minimap
            if (data.map && data.map.cells) {
              const rawCells = data.map.cells;
              const area = data.map.area || {};
              const gridW = area.size?.width || 100;
              const rawRows = Math.floor(rawCells.length / gridW);
              // Decode interleaved layers: even rows = type, odd rows = elevation
              const isInterleaved = rawRows === gridW * 2;
              const gridH = isInterleaved ? rawRows / 2 : rawRows;
              const canvasW = 150;
              const canvasH = Math.round(canvasW * (gridH / gridW));
              const cellW = canvasW / gridW;
              const cellH = canvasH / gridH;
              const canvas = document.createElement('canvas');
              canvas.id = 'plot-terrain-canvas';
              canvas.width = canvasW;
              canvas.height = canvasH;
              const ctx = canvas.getContext('2d');
              const colors = {
                0: '#2563eb', 1: '#16a34a', 2: '#92400e', 3: '#eab308',
                4: '#4ade80', 5: '#713f12', 6: '#78716c', 7: '#6b5c3e',
                8: '#60a5fa', 9: '#a8a29e', 10: '#57534e', 11: '#15803d',
                12: '#d6b88a', 13: '#166534', 14: '#1e3a5f', 15: '#c2b280',
                16: '#4a5568', 17: '#8b5e3c', 18: '#2d6a4f', 19: '#9f7e55',
                20: '#b8c4a8', 21: '#5c4033', 22: '#7c9a3e', 23: '#3a7ca5',
                24: '#6d6027', 25: '#bfa76a', 26: '#4a7c59', 27: '#c9b89e',
                28: '#8e735b', 29: '#2e4057', 30: '#536b4e', 31: '#d4a76a',
                32: '#8b7355', 33: '#5e7346', 34: '#3d5a80', 35: '#a0522d',
                36: '#6b8e6b', 37: '#9e9e78', 38: '#708090', 39: '#556b2f',
                41: '#8fbc8f', 43: '#bc8f8f', 44: '#696969', 45: '#4682b4',
                46: '#2f4f4f', 47: '#daa520', 48: '#5f9ea0', 49: '#7b6b4a',
                50: '#9acd32',
              };
              for (let y = 0; y < gridH; y++) {
                for (let x = 0; x < gridW; x++) {
                  const rawIdx = isInterleaved ? (y * 2) * gridW + x : y * gridW + x;
                  const val = rawCells[rawIdx] ?? 0;
                  ctx.fillStyle = colors[val] || '#555';
                  ctx.fillRect(x * cellW, y * cellH, cellW + 0.5, cellH + 0.5);
                }
              }
              const mapEl = document.getElementById('plot-map');
              mapEl.innerHTML = '';
              const loc = area.location;
              if (loc) {
                const posLabel = document.createElement('div');
                posLabel.style.cssText = 'font-size:11px; color:#888; margin-bottom:4px;';
                posLabel.textContent = `World position: (${loc.x}, ${loc.y}) ‚Äî ${gridW}√ó${gridH} grid`;
                mapEl.appendChild(posLabel);
              }
              mapEl.appendChild(canvas);
            } else if (data.map) {
              // Fallback: show raw tile data if cells not present
              const mapData = Array.isArray(data.map) ? data.map : [data.map];
              const tileTypes = {};
              mapData.forEach(t => {
                const type = t.tile_type || t.type || 'unknown';
                tileTypes[type] = (tileTypes[type] || 0) + 1;
              });
              const summary = Object.entries(tileTypes).map(([k,v]) => `${v}x ${k.replace(/_/g, ' ')}`).join(', ');
              document.getElementById('plot-map').innerHTML =
                `${mapData.length} tiles<br><small style="color:#888">${summary}</small>`;
            } else {
              document.getElementById('plot-map').textContent = 'No map data';
            }
          })
          .catch(() => { deepDive.style.display = 'none'; });
      }
    }, false);

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;

      // Animate for-sale beacons
      forSaleMeshes.forEach(({ glow, beam, baseOpacity }) => {
        const pulse = 0.3 + Math.sin(time * 3) * 0.3;
        glow.material.opacity = baseOpacity * (0.7 + pulse * 0.3);
        beam.material.opacity = 0.2 + pulse * 0.3;
        beam.scale.y = 1 + Math.sin(time * 2) * 0.1;
      });

      stars.rotation.y += 0.0001;

      controls.update();
      renderer.render(scene, camera);
    }

    // Fetch Chromia blockchain stats
    async function loadChainStats() {
      try {
        const response = await fetch('/api/v1/chain-stats');
        const result = await response.json();

        if (result.success) {
          if (result.players != null) {
            document.getElementById('chain-players').textContent = Number(result.players).toLocaleString();
          }
          if (result.growth) {
            const el = document.getElementById('chain-growth');
            const parts = [];
            if (result.growth.growth24h != null) parts.push(`24h: +${result.growth.growth24h.toLocaleString()}`);
            if (result.growth.growth7d != null) parts.push(`7d: +${result.growth.growth7d.toLocaleString()}`);
            if (parts.length > 0) {
              el.textContent = parts.join(' | ');
              el.style.display = 'block';
            }
          }
          if (result.assetCount != null) {
            document.getElementById('chain-assets').textContent = result.assetCount.toLocaleString();
          }
          if (result.gameVersion) {
            document.getElementById('chain-version').textContent = result.gameVersion;
          } else if (result.gameInfo) {
            const info = result.gameInfo;
            const ver = info.version || info.game_version || (typeof info === 'string' ? info : JSON.stringify(info).slice(0, 20));
            document.getElementById('chain-version').textContent = ver;
          }
          document.getElementById('chain-source').textContent = 'Chromia Mainnet';
        } else {
          document.getElementById('chain-source').textContent = 'Offline';
        }
      } catch (error) {
        console.warn('Failed to load chain stats:', error);
        document.getElementById('chain-source').textContent = 'Offline';
      }
    }

    // Fetch game economy data
    async function loadEconomy() {
      try {
        const response = await fetch('/api/v1/economy');
        const r = await response.json();
        if (!r.success) return;

        if (r.farming) {
          document.getElementById('econ-farming').textContent = `${r.farming.crops || '--'} / ${r.farming.seeds || '--'}`;
        }
        if (r.fishing) {
          document.getElementById('econ-fishing').textContent = `${r.fishing.fishTypes || '--'} types`;
        }
        if (r.crafting) {
          document.getElementById('econ-recipes').textContent = (r.crafting.recipes || '--').toLocaleString();
        }
        if (r.quests) {
          document.getElementById('econ-quests').textContent = (r.quests.total || '--').toLocaleString();
        }
        if (r.shops) {
          document.getElementById('econ-shop').textContent = `${(r.shops.listings || '--').toLocaleString()} in ${r.shops.shops || '--'} shops`;
        }
        if (r.npcs || r.tools) {
          document.getElementById('econ-misc').textContent = `${r.npcs?.total || '--'} / ${r.tools?.total || '--'}`;
        }
      } catch (error) {
        console.warn('Failed to load economy:', error);
      }
    }

    // Fetch leaderboard
    async function loadLeaderboard() {
      try {
        const response = await fetch('/api/v1/leaderboard');
        const r = await response.json();
        if (!r.success) {
          document.getElementById('lb-source').textContent = 'Offline';
          return;
        }

        const listEl = document.getElementById('leaderboard-list');
        listEl.innerHTML = '';
        (r.topPlayers || []).slice(0, 5).forEach((p, i) => {
          const div = document.createElement('div');
          div.className = 'player';
          const xpNum = Number(p.xp);
          const xpStr = xpNum >= 1000000 ? (xpNum / 1000000).toFixed(1) + 'M' : xpNum >= 1000 ? (xpNum / 1000).toFixed(0) + 'K' : p.xp;
          div.innerHTML = `<span class="rank">${i + 1}.</span><span class="name">${p.name}</span><span class="xp">${xpStr} XP</span>`;
          listEl.appendChild(div);
        });

        const whaleEl = document.getElementById('whale-list');
        whaleEl.innerHTML = '';
        const whales = r.whales || {};
        const whaleEntries = [
          ['Top Collector', whales.mostPlaceables, 'items'],
          ['Top Breeder', whales.mostAnimals, 'animals'],
          ['Top Staker', whales.mostCollateralized, 'ALICE'],
        ];
        whaleEntries.forEach(([label, data, unit]) => {
          if (!data || !data.amount) return;
          const div = document.createElement('div');
          div.className = 'whale';
          div.innerHTML = `<span class="label">${label}:</span><span class="value">${Number(data.amount).toLocaleString()} ${unit}</span>`;
          whaleEl.appendChild(div);
        });

        document.getElementById('lb-source').textContent = 'Chromia Mainnet';
      } catch (error) {
        console.warn('Failed to load leaderboard:', error);
        document.getElementById('lb-source').textContent = 'Offline';
      }
    }

    // Player search
    document.getElementById('search-input').addEventListener('keydown', (e) => {
      if (e.key !== 'Enter') return;
      const username = e.target.value.trim();
      if (!username) return;

      const resultDiv = document.getElementById('search-result');
      const errorDiv = document.getElementById('search-error');
      resultDiv.style.display = 'none';
      errorDiv.style.display = 'none';
      resultDiv.innerHTML = '';

      fetch(`/api/v1/players/${encodeURIComponent(username)}`)
        .then(r => r.json())
        .then(data => {
          if (!data.success || !data.player) {
            errorDiv.textContent = 'Player not found';
            errorDiv.style.display = 'block';
            return;
          }

          const p = data.player;
          const prog = data.progression || {};
          const plots = data.plots || {};
          const xp = prog.xp_balance != null ? Number(prog.xp_balance).toLocaleString() : '--';
          const rank = prog.rank != null ? prog.rank : '--';
          const moxie = prog.moxie_balance != null ? `${prog.moxie_balance}/${prog.max_moxie || '--'}` : '--';
          const plotCount = plots.count != null ? plots.count : '--';

          let html = `
            <div class="sr-detail"><span class="sr-label">Player</span><span class="sr-value">${p.username}</span></div>
            <div class="sr-detail"><span class="sr-label">XP</span><span class="sr-value">${xp}</span></div>
            <div class="sr-detail"><span class="sr-label">Rank</span><span class="sr-value">${rank}</span></div>
            <div class="sr-detail"><span class="sr-label">Moxie</span><span class="sr-value">${moxie}</span></div>
            <div class="sr-detail"><span class="sr-label">Plots</span><span class="sr-value">${plotCount}</span></div>
          `;

          if (plots.plotNumbers && plots.plotNumbers.length > 0) {
            html += `<div class="sr-plots"><span class="sr-label">View plots:</span><br>`;
            plots.plotNumbers.forEach(pn => {
              html += `<span class="sr-plot-btn" data-plot="${pn}">#${pn}</span>`;
            });
            html += `</div>`;
          }

          resultDiv.innerHTML = html;
          resultDiv.style.display = 'block';

          // Attach click handlers for plot buttons
          resultDiv.querySelectorAll('.sr-plot-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              const plotNum = btn.dataset.plot;
              // Find land in map by plotId
              for (const [id, land] of landDataMap) {
                if (String(land.plotId) === plotNum || String(land.id) === plotNum) {
                  zoomToLand(land);
                  break;
                }
              }
            });
          });
        })
        .catch(() => {
          errorDiv.textContent = 'Failed to fetch player data';
          errorDiv.style.display = 'block';
        });
    });

    // Storefront
    async function loadStorefront() {
      try {
        const response = await fetch('/api/v1/storefront/listings');
        const r = await response.json();
        const listEl = document.getElementById('storefront-list');

        if (!r.success || !r.listings || r.listings.length === 0) {
          listEl.textContent = 'No listings available';
          document.getElementById('sf-source').textContent = 'Offline';
          return;
        }

        listEl.innerHTML = '';
        const sorted = r.listings.slice().sort((a, b) => b.totalListings - a.totalListings);
        sorted.slice(0, 15).forEach(item => {
          const div = document.createElement('div');
          div.className = 'sf-item';
          const name = item.name.replace(/_/g, ' ');
          const floor = item.floorAlice != null ? Number(item.floorAlice).toLocaleString() : '--';
          div.innerHTML = `
            <span class="sf-name" title="${name}">${name}</span>
            <span class="sf-price">${floor} ALICE</span>
            <span class="sf-count">x${item.totalAmount || item.totalListings}</span>
          `;
          listEl.appendChild(div);
        });

        document.getElementById('sf-source').textContent = 'Chromia P2P';
      } catch (error) {
        console.warn('Failed to load storefront:', error);
        document.getElementById('storefront-list').textContent = 'Failed to load';
        document.getElementById('sf-source').textContent = 'Offline';
      }
    }

    // Position storefront dynamically below chain-stats
    function positionStorefront() {
      const chainStats = document.getElementById('chain-stats');
      const storefront = document.getElementById('storefront');
      if (chainStats && storefront) {
        const rect = chainStats.getBoundingClientRect();
        storefront.style.top = (rect.bottom + 10) + 'px';
      }
    }

    // Field Guide
    const fgToggle = document.getElementById('field-guide-toggle');
    const fgContent = document.getElementById('fg-content');
    const fgArrow = document.getElementById('fg-arrow');
    let fieldGuideLoaded = false;

    fgToggle.addEventListener('click', () => {
      const isOpen = fgContent.style.display !== 'none';
      fgContent.style.display = isOpen ? 'none' : 'block';
      fgArrow.classList.toggle('open', !isOpen);
      if (!fieldGuideLoaded) {
        fieldGuideLoaded = true;
        loadFieldGuide();
      }
    });

    // Tab switching
    document.getElementById('fg-tabs').addEventListener('click', (e) => {
      const tab = e.target.closest('.fg-tab');
      if (!tab) return;
      const tabName = tab.dataset.tab;
      document.querySelectorAll('.fg-tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      document.querySelectorAll('.fg-panel').forEach(p => p.style.display = 'none');
      document.getElementById('fg-panel-' + tabName).style.display = 'block';
    });

    function formatTime(ms) {
      if (ms >= 3600000) return (ms / 3600000).toFixed(1) + 'h';
      if (ms >= 60000) return (ms / 60000).toFixed(0) + 'm';
      return (ms / 1000).toFixed(0) + 's';
    }

    async function loadFieldGuide() {
      try {
        const response = await fetch('/api/v1/field-guide');
        const r = await response.json();
        if (!r.success) {
          document.getElementById('fg-source').textContent = 'Offline';
          return;
        }

        // Render resource nodes
        const nodesEl = document.getElementById('fg-panel-nodes');
        let currentType = '';
        let nodesHtml = '';
        for (const node of r.resourceNodes) {
          if (node.resourceType !== currentType) {
            currentType = node.resourceType;
            const emoji = { wood: 'ü™µ', stone: 'ü™®', ore: '‚õèÔ∏è', fiber: 'üåø', sediment: 'üèñÔ∏è' }[currentType] || 'üì¶';
            nodesHtml += `<div style="color:#fb923c;font-size:13px;font-weight:bold;margin:${nodesHtml ? '12px' : '0'} 0 4px;text-transform:capitalize;">${emoji} ${currentType}</div>`;
          }
          const dropList = node.drops.map(d => {
            const name = d.item.replace('resource_raw_', '').replace(/_/g, ' ');
            return `<span class="fg-drop-item">${name}${d.amount > 1 ? ` <span class="fg-drop-amount">x${d.amount}</span>` : ''}</span>`;
          }).join('');

          nodesHtml += `
            <div class="fg-node">
              <div class="fg-node-header">
                <span class="fg-node-name">${node.name.replace('resourcenode_', '').replace(/_/g, ' ')}</span>
                <span class="fg-tier">T${node.tier}</span>
              </div>
              <div class="fg-stats">
                <div>Charges: <span>${node.charges}</span></div>
                <div>Harvest: <span>${formatTime(node.harvestTime)}</span></div>
                <div>Respawn: <span>${formatTime(node.replenishTime)}</span></div>
                <div>Moxie: <span>${node.moxieDrain}</span></div>
              </div>
              <div class="fg-drops">Drops: ${dropList}</div>
              <div class="fg-tool-req">Tool: <span>${node.toolCategory}</span> (durability cost: ${node.durabilityCost})</div>
            </div>`;
        }
        nodesEl.innerHTML = nodesHtml;

        // Render tools
        const toolsEl = document.getElementById('fg-panel-tools');
        let toolsHtml = '';
        const toolEmoji = { axe: 'ü™ì', hammer: 'üî®', pickaxe: '‚õèÔ∏è', shovel: 'ü™£', sickle: 'üåæ', rod: 'üé£', hoe: 'üå±', planter: 'üåª', watering_can: 'üíß', scythe: 'üó°Ô∏è', flute: 'üéµ' };
        for (const cat of r.toolCategories) {
          const emoji = toolEmoji[cat.category] || 'üîß';
          toolsHtml += `<div class="fg-tool-card">
            <span class="fg-tool-name">${emoji} ${cat.category.replace(/_/g, ' ')}</span>
            <span class="fg-tool-tiers">${cat.tools.map(t =>
              `<span class="fg-tool-tier">T${t.tier}: <span>${t.durability}</span></span>`
            ).join('')}</span>
          </div>`;
        }
        toolsEl.innerHTML = toolsHtml || 'No tool data';

        // Render mystery box seeds
        const mysteryEl = document.getElementById('fg-panel-mystery');
        if (r.mysteryBox && r.mysteryBox.entries) {
          const totalWeight = r.mysteryBox.entries.reduce((s, e) => s + Math.max(e.weight, 0), 0);
          let seedHtml = `<div style="color:#4ade80;font-size:12px;margin-bottom:8px;">üéÅ Mysterious Seeds Box ‚Äî ${r.mysteryBox.entries.length} possible drops</div>`;
          for (const entry of r.mysteryBox.entries) {
            const name = entry.item.replace('seed_', '').replace(/_/g, ' ');
            const pct = totalWeight > 0 ? ((Math.max(entry.weight, 0) / totalWeight) * 100).toFixed(0) : '?';
            seedHtml += `<span class="fg-seed">${name} <span style="color:#888;font-size:10px;">${pct}%</span></span>`;
          }
          mysteryEl.innerHTML = seedHtml;
        } else {
          mysteryEl.textContent = 'No mystery box data';
        }

        document.getElementById('fg-source').textContent = `Chromia (${r.totalNodes} nodes, ${r.totalTools} tools)`;
      } catch (error) {
        console.warn('Failed to load field guide:', error);
        document.getElementById('fg-source').textContent = 'Offline';
      }
    }

    // === Direct plot view via ?plot=NUMBER ===
    function checkDirectPlotView() {
      const params = new URLSearchParams(window.location.search);
      const plotNum = params.get('plot');
      if (!plotNum) return;
      // Fetch plot data and enter 3D view directly
      fetch(`/api/v1/plots/${encodeURIComponent(plotNum)}`)
        .then(r => r.json())
        .then(data => {
          if (!data.success || !data.map || !data.map.cells) {
            console.warn('Direct plot view: no map data for plot', plotNum);
            return;
          }
          // Hide loading screen if still showing
          const loading = document.getElementById('loading');
          if (loading) loading.style.display = 'none';
          enterPlotView(data, { name: `Plot #${plotNum}`, plotId: plotNum });
        })
        .catch(err => console.warn('Direct plot view failed:', err));
    }

    // Initialize
    loadLands();
    loadChainStats();
    loadEconomy();
    loadLeaderboard();
    loadStorefront();
    // Check for direct plot view after a brief delay for scene setup
    setTimeout(checkDirectPlotView, 1000);
    // Refresh storefront every 2 minutes
    setInterval(loadStorefront, 2 * 60 * 1000);
    // Position storefront after a brief delay for layout
    setTimeout(positionStorefront, 500);
    window.addEventListener('resize', positionStorefront);
    animate();

    // === Draggable + Collapsible Panel System ===
    document.querySelectorAll('.draggable-panel').forEach(panel => {
      const header = panel.querySelector('.panel-header');
      const collapseBtn = panel.querySelector('.panel-collapse-btn');
      if (!header) return;

      // Collapse/expand on button click
      if (collapseBtn) {
        collapseBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const collapsed = panel.classList.toggle('panel-collapsed');
          collapseBtn.textContent = collapsed ? '+' : '‚àí';
          collapseBtn.title = collapsed ? 'Expand' : 'Minimize';
        });
      }

      // Drag on header
      let isDragging = false;
      let dragStartX, dragStartY, panelStartX, panelStartY;

      header.addEventListener('mousedown', (e) => {
        // Don't drag if clicking the collapse button or an input
        if (e.target.closest('.panel-collapse-btn') || e.target.tagName === 'INPUT') return;

        isDragging = true;
        panel.classList.add('panel-dragging');

        // Get current position (handle both positioned and auto-positioned panels)
        const rect = panel.getBoundingClientRect();
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        panelStartX = rect.left;
        panelStartY = rect.top;

        // Switch from CSS positioning to absolute pixel positioning
        panel.style.left = rect.left + 'px';
        panel.style.top = rect.top + 'px';
        panel.style.right = 'auto';
        panel.style.bottom = 'auto';

        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        panel.style.left = (panelStartX + dx) + 'px';
        panel.style.top = (panelStartY + dy) + 'px';
      });

      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          panel.classList.remove('panel-dragging');
        }
      });
    });

  </script>
</body>
</html>
