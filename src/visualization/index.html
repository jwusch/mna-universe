<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My Neighbor Alice Universe - REAL DATA 3D Visualization</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      background: #0a0a1a;
    }
    #container {
      width: 100vw;
      height: 100vh;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 14px;
      max-width: 340px;
      z-index: 100;
      border: 1px solid rgba(125, 211, 252, 0.3);
      backdrop-filter: blur(10px);
    }
    #info h1 {
      font-size: 18px;
      margin-bottom: 8px;
      color: #7dd3fc;
      text-shadow: 0 0 20px rgba(125, 211, 252, 0.5);
    }
    #info .real-data-badge {
      display: inline-block;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: bold;
      margin-left: 8px;
      text-transform: uppercase;
    }
    #info p {
      margin: 5px 0;
      color: #aaa;
      font-size: 12px;
    }
    #info .highlight {
      color: #fbbf24;
    }
    #stats {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 14px;
      z-index: 100;
      border: 1px solid rgba(251, 191, 36, 0.3);
      backdrop-filter: blur(10px);
      min-width: 200px;
    }
    #stats h3 {
      color: #fbbf24;
      margin-bottom: 10px;
      font-size: 14px;
    }
    #stats .stat {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
      font-size: 13px;
    }
    #stats .stat-value {
      color: #4ade80;
      font-weight: bold;
    }
    #stats .source {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.1);
      font-size: 11px;
      color: #666;
    }
    #stats .source span {
      color: #22c55e;
    }
    #legend {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 15px 20px;
      border-radius: 12px;
      z-index: 100;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
    }
    #legend h3 {
      font-size: 14px;
      margin-bottom: 10px;
      color: #7dd3fc;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin: 6px 0;
      font-size: 12px;
    }
    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    #land-info {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      padding: 20px;
      border-radius: 12px;
      font-size: 14px;
      max-width: 320px;
      z-index: 100;
      display: none;
      border: 1px solid rgba(251, 191, 36, 0.5);
      backdrop-filter: blur(10px);
    }
    #land-info h2 {
      font-size: 16px;
      margin-bottom: 8px;
      color: #fbbf24;
    }
    #land-info .plot-id {
      font-size: 11px;
      color: #666;
      margin-bottom: 12px;
    }
    #land-info .detail {
      margin: 8px 0;
      display: flex;
      justify-content: space-between;
      font-size: 13px;
    }
    #land-info .label {
      color: #888;
    }
    #land-info .value {
      color: #fff;
      font-weight: 500;
      text-align: right;
      max-width: 60%;
    }
    #land-info .for-sale {
      margin-top: 15px;
      padding: 12px;
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(34, 197, 94, 0.1));
      border-radius: 8px;
      text-align: center;
      border: 1px solid rgba(34, 197, 94, 0.3);
    }
    #land-info .for-sale .price {
      color: #22c55e;
      font-size: 20px;
      font-weight: bold;
    }
    #land-info .for-sale .seller {
      color: #888;
      font-size: 11px;
      margin-top: 4px;
    }
    #land-info .actions {
      display: flex;
      gap: 8px;
      margin-top: 15px;
    }
    #land-info .action-btn {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.2s;
    }
    #land-info .zoom-btn {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: white;
    }
    #land-info .zoom-btn:hover {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      transform: translateY(-1px);
    }
    #land-info .map-btn {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
      text-decoration: none;
      text-align: center;
    }
    #land-info .map-btn:hover {
      background: linear-gradient(135deg, #d97706, #b45309);
      transform: translateY(-1px);
    }
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      color: #4ade80;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
      border: 1px solid rgba(74, 222, 128, 0.3);
    }
    .toast.show {
      opacity: 1;
    }
    #land-info .soil-water {
      display: flex;
      gap: 10px;
      margin-top: 8px;
      font-size: 11px;
    }
    #land-info .soil-water span {
      padding: 4px 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #7dd3fc;
      font-size: 20px;
      z-index: 200;
      text-align: center;
      text-shadow: 0 0 20px rgba(125, 211, 252, 0.5);
    }
    #loading .sub {
      font-size: 14px;
      color: #888;
      margin-top: 10px;
    }
    .pulse {
      animation: pulse 2s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    #regions {
      position: absolute;
      top: 140px;
      right: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 12px 15px;
      border-radius: 12px;
      font-size: 12px;
      z-index: 100;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      max-height: 200px;
      overflow-y: auto;
    }
    #regions h4 {
      color: #7dd3fc;
      margin-bottom: 8px;
      font-size: 12px;
    }
    #regions .region {
      padding: 3px 0;
      color: #888;
    }
    #updating {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #7dd3fc;
      font-size: 14px;
      z-index: 150;
      text-align: center;
      opacity: 0.7;
      pointer-events: none;
      display: none;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <div id="info">
    <h1>My Neighbor Alice<span class="real-data-badge">REAL DATA</span></h1>
    <p>Pan: Right-click + drag | Zoom: Scroll | Rotate: Left-click + drag</p>
    <p class="highlight">Click on a land to see details</p>
    <p class="highlight pulse">Golden glowing lands are FOR SALE!</p>
  </div>

  <div id="stats">
    <h3>World Statistics</h3>
    <div class="stat">
      <span>Total Lands:</span>
      <span class="stat-value" id="total-lands">0</span>
    </div>
    <div class="stat">
      <span>For Sale:</span>
      <span class="stat-value" id="for-sale-count">0</span>
    </div>
    <div class="stat">
      <span>Price Range:</span>
      <span class="stat-value" id="price-range">-</span>
    </div>
    <div class="stat">
      <span>Islands:</span>
      <span class="stat-value" id="island-count">0</span>
    </div>
    <div class="source">
      Data: <span id="data-source">loading...</span>
    </div>
  </div>

  <div id="regions">
    <h4>Regions</h4>
    <div id="region-list"></div>
  </div>

  <div id="legend">
    <h3>Regions / Biomes</h3>
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(135deg, #4ade80, #22c55e);"></div>
      <span>Plains / Wolds</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(135deg, #166534, #14532d);"></div>
      <span>Forest / Gulch</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(135deg, #fbbf24, #d4a574);"></div>
      <span>Desert / Sandy</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(135deg, #38bdf8, #0ea5e9);"></div>
      <span>Water / Falls</span>
    </div>
  </div>

  <div id="land-info">
    <h2 id="land-name">Land Name</h2>
    <div class="plot-id" id="plot-id">Plot #0000000</div>
    <div class="detail">
      <span class="label">Island</span>
      <span class="value" id="land-island">Unknown</span>
    </div>
    <div class="detail">
      <span class="label">Region</span>
      <span class="value" id="land-region">Unknown</span>
    </div>
    <div class="detail">
      <span class="label">Coordinates</span>
      <span class="value" id="land-coords">(0, 0)</span>
    </div>
    <div class="detail">
      <span class="label">Biome</span>
      <span class="value" id="land-biome">Plains</span>
    </div>
    <div class="soil-water">
      <span id="land-soil">Soil: unknown</span>
      <span id="land-water">Water: unknown</span>
    </div>
    <div id="land-sale" class="for-sale" style="display: none;">
      <div class="price"><span id="land-price">0</span> ALICE</div>
      <div class="seller">Seller: <span id="land-seller">Unknown</span></div>
    </div>
    <div class="actions">
      <button class="action-btn zoom-btn" id="zoom-btn">üîç Zoom</button>
      <a class="action-btn map-btn" id="map-btn" href="#" target="_blank">üó∫Ô∏è MNA Map</a>
    </div>
  </div>

  <div id="loading">
    Loading Real MNA Universe...
    <div class="sub">Fetching from mkpl-api.prod.myneighboralice.com</div>
  </div>

  <div id="updating">Updating land data...</div>

  <div id="toast" class="toast">Plot ID copied!</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Biome colors
    const BIOME_COLORS = {
      plains: 0x4ade80,
      forest: 0x166534,
      desert: 0xd4a574,
      water: 0x38bdf8,
    };

    // Biome heights
    const BIOME_HEIGHTS = {
      plains: 0.3,
      forest: 0.5,
      desert: 0.2,
      water: -0.1,
    };

    // Scene setup
    const container = document.getElementById('container');
    const scene = new THREE.Scene();

    // Create gradient sky
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.ShaderMaterial({
      uniforms: {
        topColor: { value: new THREE.Color(0x0a0a2e) },
        bottomColor: { value: new THREE.Color(0x1a1a4e) },
        offset: { value: 33 },
        exponent: { value: 0.6 }
      },
      vertexShader: `
        varying vec3 vWorldPosition;
        void main() {
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 topColor;
        uniform vec3 bottomColor;
        uniform float offset;
        uniform float exponent;
        varying vec3 vWorldPosition;
        void main() {
          float h = normalize(vWorldPosition + offset).y;
          gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
        }
      `,
      side: THREE.BackSide
    });
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    // Add stars
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 2000;
    const starPositions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount * 3; i += 3) {
      const radius = 400 + Math.random() * 50;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      starPositions[i] = radius * Math.sin(phi) * Math.cos(theta);
      starPositions[i + 1] = radius * Math.cos(phi);
      starPositions[i + 2] = radius * Math.sin(phi) * Math.sin(theta);
    }
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8 });
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    // Camera - far clipping plane extended for large world
    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      2000
    );
    camera.position.set(80, 60, 80);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // Controls - extended for large world
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 500;
    controls.maxPolarAngle = Math.PI / 2.1;

    // Lights
    const ambientLight = new THREE.AmbientLight(0x404080, 0.5);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfff5e0, 1.2);
    sunLight.position.set(100, 80, 60);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 4096;
    sunLight.shadow.mapSize.height = 4096;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 400;
    sunLight.shadow.camera.left = -150;
    sunLight.shadow.camera.right = 150;
    sunLight.shadow.camera.top = 150;
    sunLight.shadow.camera.bottom = -150;
    scene.add(sunLight);

    const rimLight = new THREE.DirectionalLight(0x8080ff, 0.3);
    rimLight.position.set(-20, 10, -20);
    scene.add(rimLight);

    // Ocean plane - large enough for full coordinate range
    const oceanGeometry = new THREE.PlaneGeometry(500, 500);
    const oceanMaterial = new THREE.MeshPhongMaterial({
      color: 0x0066aa,
      transparent: true,
      opacity: 0.7,
      shininess: 100,
    });
    const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
    ocean.rotation.x = -Math.PI / 2;
    ocean.position.set(80, -0.5, 45); // Center on the coordinate range
    scene.add(ocean);

    // Store land meshes for raycasting
    const landMeshes = [];
    const landDataMap = new Map();
    const forSaleMeshes = [];

    // Create a tree
    function createTree(x, z, scale = 1) {
      const group = new THREE.Group();

      const trunkGeometry = new THREE.CylinderGeometry(0.05 * scale, 0.08 * scale, 0.4 * scale, 8);
      const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = 0.2 * scale;
      trunk.castShadow = true;
      group.add(trunk);

      const foliageGeometry = new THREE.ConeGeometry(0.2 * scale, 0.5 * scale, 8);
      const foliageMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
      const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
      foliage.position.y = 0.55 * scale;
      foliage.castShadow = true;
      group.add(foliage);

      group.position.set(x, 0, z);
      return group;
    }

    // Create a building
    function createBuilding(type, scale = 1) {
      const group = new THREE.Group();

      if (type === 'house') {
        const baseGeometry = new THREE.BoxGeometry(0.5 * scale, 0.4 * scale, 0.5 * scale);
        const baseMaterial = new THREE.MeshPhongMaterial({ color: 0xf5deb3 });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = 0.2 * scale;
        base.castShadow = true;
        group.add(base);

        const roofGeometry = new THREE.ConeGeometry(0.45 * scale, 0.3 * scale, 4);
        const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x8B0000 });
        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
        roof.position.y = 0.55 * scale;
        roof.rotation.y = Math.PI / 4;
        roof.castShadow = true;
        group.add(roof);
      } else if (type === 'tower') {
        const towerGeometry = new THREE.CylinderGeometry(0.15 * scale, 0.2 * scale, 0.8 * scale, 8);
        const towerMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
        const tower = new THREE.Mesh(towerGeometry, towerMaterial);
        tower.position.y = 0.4 * scale;
        tower.castShadow = true;
        group.add(tower);

        const topGeometry = new THREE.ConeGeometry(0.2 * scale, 0.25 * scale, 8);
        const topMaterial = new THREE.MeshPhongMaterial({ color: 0x4169E1 });
        const top = new THREE.Mesh(topGeometry, topMaterial);
        top.position.y = 0.9 * scale;
        top.castShadow = true;
        group.add(top);
      }

      return group;
    }

    // Create land mesh with terrain
    function createLandMesh(land) {
      const group = new THREE.Group();
      const baseHeight = BIOME_HEIGHTS[land.biome] || 0.3;
      const color = BIOME_COLORS[land.biome] || 0x888888;

      // Use actual land dimensions, with a minimum size for visibility
      const landWidth = Math.max(land.width || 0.8, 0.5);
      const landDepth = Math.max(land.height || 0.8, 0.5);
      const landSize = Math.max(landWidth, landDepth);

      // Main terrain block
      const geometry = new THREE.BoxGeometry(landWidth * 0.95, baseHeight + 0.1, landDepth * 0.95);
      const material = new THREE.MeshPhongMaterial({
        color: color,
        shininess: land.biome === 'water' ? 80 : 20,
        transparent: land.biome === 'water',
        opacity: land.biome === 'water' ? 0.85 : 1,
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.y = (baseHeight + 0.1) / 2;
      mesh.castShadow = true;
      mesh.receiveShadow = true;

      mesh.userData = { landId: land.id };
      landDataMap.set(land.id, land);
      landMeshes.push(mesh);

      group.add(mesh);

      // Add decorations based on biome (scaled to land size)
      if (land.biome === 'forest' && landSize > 0.3) {
        const treeCount = Math.floor(1 + Math.random() * 2);
        for (let i = 0; i < treeCount; i++) {
          const tx = (Math.random() - 0.5) * landWidth * 0.6;
          const tz = (Math.random() - 0.5) * landDepth * 0.6;
          const scale = 0.3 + Math.random() * 0.3;
          const tree = createTree(tx, tz, scale);
          tree.position.y = baseHeight + 0.1;
          group.add(tree);
        }
      }

      // Add buildings to some plains
      if (land.biome === 'plains' && Math.random() > 0.85 && landSize > 0.5) {
        const buildingType = Math.random() > 0.5 ? 'house' : 'tower';
        const building = createBuilding(buildingType, 0.5);
        building.position.y = baseHeight + 0.1;
        group.add(building);
      }

      // For sale glow effect
      if (land.forSale) {
        const glowGeometry = new THREE.BoxGeometry(landWidth, 0.02, landDepth);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0xfbbf24,
          transparent: true,
          opacity: 0.6,
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.position.y = baseHeight + 0.12;
        group.add(glow);

        // Vertical beam
        const beamGeometry = new THREE.CylinderGeometry(0.03, 0.03, 3, 8);
        const beamMaterial = new THREE.MeshBasicMaterial({
          color: 0xfbbf24,
          transparent: true,
          opacity: 0.4,
        });
        const beam = new THREE.Mesh(beamGeometry, beamMaterial);
        beam.position.y = baseHeight + 1.6;
        group.add(beam);

        forSaleMeshes.push({ glow, beam, baseOpacity: 0.6 });
      }

      // Position the group using scaled coordinates
      group.position.set(land.x, 0, land.y);

      return group;
    }

    // Fetch and render lands
    let landsRendered = false;

    function renderLands(lands, stats, source) {
      // Clear previous land meshes
      if (landsRendered) {
        landMeshes.forEach(mesh => {
          // mesh is inside a Group; remove the Group from the scene
          const group = mesh.parent;
          if (group) scene.remove(group);
        });
        landMeshes.length = 0;
        landDataMap.clear();
        forSaleMeshes.length = 0;
      }

      // Update stats
      document.getElementById('total-lands').textContent = lands.length;
      const forSaleLands = lands.filter(l => l.forSale);
      document.getElementById('for-sale-count').textContent = forSaleLands.length;

      if (forSaleLands.length > 0) {
        const prices = forSaleLands.map(l => l.price || 0).filter(p => p > 0);
        if (prices.length > 0) {
          const minPrice = Math.min(...prices);
          const maxPrice = Math.max(...prices);
          document.getElementById('price-range').textContent = `${minPrice}-${maxPrice} ALICE`;
        }
      }

      if (stats) {
        document.getElementById('island-count').textContent = stats.islands?.length || 1;

        const regionList = document.getElementById('region-list');
        regionList.innerHTML = '';
        (stats.regions || []).slice(0, 8).forEach(region => {
          const div = document.createElement('div');
          div.className = 'region';
          div.textContent = region;
          regionList.appendChild(div);
        });
      }

      document.getElementById('data-source').textContent = source || 'mna-marketplace-api';

      // Render land meshes
      lands.forEach(land => {
        const mesh = createLandMesh(land);
        scene.add(mesh);
      });

      // Center camera on first render
      if (!landsRendered && lands.length > 0) {
        const xs = lands.map(l => l.x);
        const ys = lands.map(l => l.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const worldWidth = maxX - minX;
        const worldDepth = maxY - minY;
        const worldSize = Math.max(worldWidth, worldDepth);

        controls.target.set(centerX, 0, centerY);
        const cameraDistance = worldSize * 0.6;
        camera.position.set(centerX + cameraDistance * 0.5, cameraDistance * 0.4, centerY + cameraDistance * 0.5);

        console.log(`World bounds: X(${minX.toFixed(1)}-${maxX.toFixed(1)}), Y(${minY.toFixed(1)}-${maxY.toFixed(1)})`);
        console.log(`World center: (${centerX.toFixed(1)}, ${centerY.toFixed(1)}), size: ${worldSize.toFixed(1)}`);
      }

      landsRendered = true;
      document.getElementById('loading').style.display = 'none';
    }

    async function loadLands() {
      const CACHE_KEY = 'mna_lands_cache';
      const CACHE_MAX_AGE = 10 * 60 * 1000; // 10 minutes

      // Check localStorage for cached data
      let cachedResult = null;
      try {
        const raw = localStorage.getItem(CACHE_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          if (parsed.timestamp && (Date.now() - parsed.timestamp) < CACHE_MAX_AGE) {
            cachedResult = parsed;
          }
        }
      } catch (e) {
        console.warn('Failed to read cache:', e);
      }

      // If we have valid cached data, render immediately
      if (cachedResult) {
        console.log(`Rendering ${cachedResult.data.length} lands from localStorage cache`);
        renderLands(cachedResult.data, cachedResult.stats, cachedResult.source + ' (cached)');

        // Background refresh
        document.getElementById('updating').style.display = 'block';
        try {
          const response = await fetch('/api/v1/lands');
          const result = await response.json();
          if (result.success && result.data) {
            // Save to localStorage
            try {
              localStorage.setItem(CACHE_KEY, JSON.stringify({
                data: result.data,
                stats: result.stats,
                source: result.source,
                timestamp: Date.now(),
              }));
            } catch (e) {
              console.warn('Failed to write cache:', e);
            }

            // Re-render if data changed
            if (result.data.length !== cachedResult.data.length) {
              console.log(`Data changed (${cachedResult.data.length} -> ${result.data.length}), re-rendering`);
              renderLands(result.data, result.stats, result.source);
            }
          }
        } catch (error) {
          console.warn('Background refresh failed:', error);
        } finally {
          document.getElementById('updating').style.display = 'none';
        }
        return;
      }

      // No cache ‚Äî full loading screen fetch
      try {
        const response = await fetch('/api/v1/lands');
        const result = await response.json();

        if (result.success && result.data) {
          console.log(`Loaded ${result.data.length} REAL lands from ${result.source}`);

          // Save to localStorage
          try {
            localStorage.setItem(CACHE_KEY, JSON.stringify({
              data: result.data,
              stats: result.stats,
              source: result.source,
              timestamp: Date.now(),
            }));
          } catch (e) {
            console.warn('Failed to write cache:', e);
          }

          renderLands(result.data, result.stats, result.source);
        }
      } catch (error) {
        console.error('Failed to load lands:', error);
        document.getElementById('loading').innerHTML =
          'Failed to load lands.<br><span class="sub">Is the server running?</span>';
      }
    }

    // Raycaster for click detection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedMesh = null;
    let selectedLand = null;

    // Zoom to a specific land
    function zoomToLand(land) {
      if (!land) return;

      const targetX = land.x;
      const targetZ = land.y;

      // Animate camera to the land
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const endTarget = new THREE.Vector3(targetX, 0, targetZ);
      const endPos = new THREE.Vector3(targetX + 5, 8, targetZ + 5);

      const duration = 1000;
      const startTime = Date.now();

      function animateZoom() {
        const elapsed = Date.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        // Ease out cubic
        const eased = 1 - Math.pow(1 - t, 3);

        camera.position.lerpVectors(startPos, endPos, eased);
        controls.target.lerpVectors(startTarget, endTarget, eased);

        if (t < 1) {
          requestAnimationFrame(animateZoom);
        }
      }
      animateZoom();
    }

    // Toast notification
    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2000);
    }

    // Set up button handlers
    document.getElementById('zoom-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      if (selectedLand) {
        zoomToLand(selectedLand);
      }
    });


    function onMouseClick(event) {
      // Ignore clicks on the info panel
      if (event.target.closest('#land-info')) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(landMeshes);

      if (selectedMesh) {
        selectedMesh.material.emissive.setHex(0x000000);
      }

      if (intersects.length > 0) {
        const mesh = intersects[0].object;
        const landId = mesh.userData.landId;
        const land = landDataMap.get(landId);

        if (land) {
          selectedMesh = mesh;
          selectedLand = land;
          mesh.material.emissive.setHex(0x333333);

          // Update info panel
          document.getElementById('land-name').textContent = land.name;
          document.getElementById('plot-id').textContent = `Plot #${land.plotId || land.id}`;
          document.getElementById('land-island').textContent = land.island || 'Unknown';
          document.getElementById('land-region').textContent = land.region || 'Unknown';
          document.getElementById('land-coords').textContent = `(${land.realX || land.x}, ${land.realY || land.y})`;
          document.getElementById('land-biome').textContent = (land.biome || 'plains').charAt(0).toUpperCase() + (land.biome || 'plains').slice(1);
          document.getElementById('land-soil').textContent = `Soil: ${land.soilType || 'unknown'}`;
          document.getElementById('land-water').textContent = `Water: ${land.waterType || 'unknown'}`;

          const saleDiv = document.getElementById('land-sale');
          if (land.forSale && land.price) {
            saleDiv.style.display = 'block';
            document.getElementById('land-price').textContent = land.price.toFixed(2);
            document.getElementById('land-seller').textContent = land.seller || 'Unknown';
          } else {
            saleDiv.style.display = 'none';
          }

          // Update MNA map link - deep link to specific land plot
          const mapBtn = document.getElementById('map-btn');
          const plotId = land.plotId || land.id;
          mapBtn.href = `https://myneighboralice.com/map/${plotId}`;
          mapBtn.title = `View Plot #${plotId} on MNA in-game map`;

          document.getElementById('land-info').style.display = 'block';
          console.log('Selected land:', land);
        }
      } else {
        document.getElementById('land-info').style.display = 'none';
        selectedMesh = null;
        selectedLand = null;
      }
    }

    window.addEventListener('click', onMouseClick, false);

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;

      // Animate for-sale beacons
      forSaleMeshes.forEach(({ glow, beam, baseOpacity }) => {
        const pulse = 0.3 + Math.sin(time * 3) * 0.3;
        glow.material.opacity = baseOpacity * (0.7 + pulse * 0.3);
        beam.material.opacity = 0.2 + pulse * 0.3;
        beam.scale.y = 1 + Math.sin(time * 2) * 0.1;
      });

      stars.rotation.y += 0.0001;

      controls.update();
      renderer.render(scene, camera);
    }

    // Initialize
    loadLands();
    animate();
  </script>
</body>
</html>
